{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Quantum Information Research Toolkit Documentation","text":""},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol>"},{"location":"reference/","title":"Reference","text":"<p>Quantum Information Research Toolkit</p> <p>The Quantum Information Research Toolkit (QIRT) provides enhanced functionalities for working with quantum circuits and state vectors, extending the capabilities of Qiskit's QuantumCircuit and Statevector classes. QIRT includes modules for basis conversion, state vector manipulations, and various visualizations in LaTeX.</p> <p>Modules:</p> Name Description <code>quantum_operation</code> <p>Extends Qiskit's QuantumCircuit class with additional methods                for basis conversion and visualization.</p> <code>quantum_state</code> <p>Extends Qiskit's Statevector class with methods for state manipulations,            basis conversions, and visualizations.</p> <p>The functionalities added in QIRT are:</p> <ul> <li> <p>Conversion of quantum circuits to matrix form.</p> </li> <li> <p>Drawing quantum circuits or their matrix representations.</p> </li> <li> <p>Basis conversion for qubits within circuits.</p> </li> <li> <p>Creation and manipulation of state vectors.</p> </li> <li> <p>Calculation of quantum state entropy.</p> </li> <li> <p>Evolution of quantum states using various operators.</p> </li> <li> <p>Visualization of quantum states in LaTeX or matrix form.</p> </li> <li> <p>Measurement of qubits and obtaining resulting states.</p> </li> </ul> See Also <p>Qiskit QuantumCircuit documentation</p> <p>Qiskit Statevector documentation</p>"},{"location":"reference/#QIRT.QuantumOperation","title":"<code>QuantumOperation</code>","text":"<p>               Bases: <code>QuantumCircuit</code></p> <p>An extended class of QuantumCircuit from Qiskit.</p> <p>This class extends the QuantumCircuit class from Qiskit to provide additional functionalities for converting basis and visualizing the quantum circuit in matrix form.</p> See Also <p>Qiskit QuantumCircuit documentation</p> Source code in <code>QIRT/quantum_operation.py</code> <pre><code>class QuantumOperation(QuantumCircuit):\n    \"\"\"An extended class of QuantumCircuit from Qiskit.\n\n    This class extends the QuantumCircuit class from Qiskit to provide additional\n    functionalities for converting basis and visualizing the quantum circuit in\n    matrix form.\n\n    See Also:\n        [Qiskit QuantumCircuit documentation](https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html)\n    \"\"\"\n\n    def to_matrix(self) -&gt; NDArray[np.complex128]:\n        \"\"\"Return matrix form of the quantum circuit as a numpy array.\n\n        This method returns the matrix representation of the quantum circuit by\n        reversing the order of qubits to match textbook notation.\n\n        Returns:\n            NDArray[np.complex128]: The matrix representation of the quantum circuit.\n        \"\"\"\n        reverse_qc = self.reverse_bits()  # REVERSE the order of qubits to match textbook notation\n        return np.asarray(quantum_info.Operator(reverse_qc).data, dtype=np.complex128)\n\n    def draw(self, output: str | None = \"mpl\", source: bool = False, *args, **kwargs):\n        \"\"\"Draw the quantum circuit, or show its matrix form if output is 'matrix'.\n\n        Args:\n            output (str | None, optional): The output format for drawing the circuit.\n                If 'text', generates ASCII art TextDrawing that can be printed in the console.\\n\n                If 'mpl', generates images with color rendered purely in Python using matplotlib.\\n\n                If 'latex', generates high-quality images compiled via latex.\\n\n                If 'matrix', shows the matrix form of the circuit. Defaults to \"mpl\".\n            source (bool, optional): Whether to return the latex source code for the visualization. Defaults to False.\n            *args: Additional positional arguments to pass to the draw method.\n            **kwargs: Additional keyword arguments to pass to the draw method.\n\n        Returns:\n            The drawn circuit in the specified format.\n        \"\"\"\n        match output:\n            case \"matrix\":\n                return latex_drawer.matrix_to_latex(self.to_matrix(), source=source)\n            case \"latex\":\n                if source:\n                    return super().draw(output=\"latex_source\", *args, **kwargs)\n                return super().draw(output=\"latex\", *args, **kwargs)\n            case _:\n                return super().draw(output=output, *args, **kwargs)\n\n    def _xyz_convert_circ(self, target_basis: str, current_basis: str, qubit_index: int) -&gt; None:\n        \"\"\"Add the corresponding gate that converts different basis.\n\n        This method adds the appropriate gates to the circuit to convert a qubit\n        from the current basis to the target basis.\n\n        Args:\n            target_basis (str): The target basis to convert to.\n            current_basis (str): The current basis of the qubit.\n            qubit_index (int): The index of the qubit to be converted.\n        \"\"\"\n        if current_basis == target_basis:\n            return\n        current_basis += target_basis\n        match current_basis:\n            case \"zx\" | \"xz\":\n                self.h(qubit_index)\n            case \"zy\":\n                self.sdg(qubit_index)\n                self.h(qubit_index)\n            case \"yz\":\n                self.h(qubit_index)\n                self.s(qubit_index)\n            case \"xy\":\n                self.h(qubit_index)\n                self.sdg(qubit_index)\n                self.h(qubit_index)\n            case \"yx\":\n                self.h(qubit_index)\n                self.s(qubit_index)\n                self.h(qubit_index)\n        return\n</code></pre>"},{"location":"reference/#QIRT.QuantumOperation.draw","title":"<code>draw(output='mpl', source=False, *args, **kwargs)</code>","text":"<p>Draw the quantum circuit, or show its matrix form if output is 'matrix'.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str | None</code> <p>The output format for drawing the circuit. If 'text', generates ASCII art TextDrawing that can be printed in the console.</p> <p>If 'mpl', generates images with color rendered purely in Python using matplotlib.</p> <p>If 'latex', generates high-quality images compiled via latex.</p> <p>If 'matrix', shows the matrix form of the circuit. Defaults to \"mpl\".</p> <code>'mpl'</code> <code>source</code> <code>bool</code> <p>Whether to return the latex source code for the visualization. Defaults to False.</p> <code>False</code> <code>*args</code> <p>Additional positional arguments to pass to the draw method.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the draw method.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The drawn circuit in the specified format.</p> Source code in <code>QIRT/quantum_operation.py</code> <pre><code>def draw(self, output: str | None = \"mpl\", source: bool = False, *args, **kwargs):\n    \"\"\"Draw the quantum circuit, or show its matrix form if output is 'matrix'.\n\n    Args:\n        output (str | None, optional): The output format for drawing the circuit.\n            If 'text', generates ASCII art TextDrawing that can be printed in the console.\\n\n            If 'mpl', generates images with color rendered purely in Python using matplotlib.\\n\n            If 'latex', generates high-quality images compiled via latex.\\n\n            If 'matrix', shows the matrix form of the circuit. Defaults to \"mpl\".\n        source (bool, optional): Whether to return the latex source code for the visualization. Defaults to False.\n        *args: Additional positional arguments to pass to the draw method.\n        **kwargs: Additional keyword arguments to pass to the draw method.\n\n    Returns:\n        The drawn circuit in the specified format.\n    \"\"\"\n    match output:\n        case \"matrix\":\n            return latex_drawer.matrix_to_latex(self.to_matrix(), source=source)\n        case \"latex\":\n            if source:\n                return super().draw(output=\"latex_source\", *args, **kwargs)\n            return super().draw(output=\"latex\", *args, **kwargs)\n        case _:\n            return super().draw(output=output, *args, **kwargs)\n</code></pre>"},{"location":"reference/#QIRT.QuantumOperation.to_matrix","title":"<code>to_matrix()</code>","text":"<p>Return matrix form of the quantum circuit as a numpy array.</p> <p>This method returns the matrix representation of the quantum circuit by reversing the order of qubits to match textbook notation.</p> <p>Returns:</p> Type Description <code>NDArray[complex128]</code> <p>NDArray[np.complex128]: The matrix representation of the quantum circuit.</p> Source code in <code>QIRT/quantum_operation.py</code> <pre><code>def to_matrix(self) -&gt; NDArray[np.complex128]:\n    \"\"\"Return matrix form of the quantum circuit as a numpy array.\n\n    This method returns the matrix representation of the quantum circuit by\n    reversing the order of qubits to match textbook notation.\n\n    Returns:\n        NDArray[np.complex128]: The matrix representation of the quantum circuit.\n    \"\"\"\n    reverse_qc = self.reverse_bits()  # REVERSE the order of qubits to match textbook notation\n    return np.asarray(quantum_info.Operator(reverse_qc).data, dtype=np.complex128)\n</code></pre>"},{"location":"reference/#QIRT.QuantumState","title":"<code>QuantumState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>An extended class of Statevector from Qiskit.</p> <p>This class extends the Statevector class from Qiskit to provide additional functionalities specific to quantum state manipulations and measurements.</p> <p>Attributes:</p> Name Type Description <code>_num_of_qubit</code> <code>int</code> <p>The number of qubits in the quantum state.</p> See Also <p>Qiskit Statevector documentation</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>class QuantumState(Statevector):\n    \"\"\"An extended class of Statevector from Qiskit.\n\n    This class extends the Statevector class from Qiskit to provide additional\n    functionalities specific to quantum state manipulations and measurements.\n\n    Attributes:\n        _num_of_qubit (int): The number of qubits in the quantum state.\n\n    See Also:\n        [Qiskit Statevector documentation](https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html)\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize a QuantumState object.\n\n        This constructor initializes the QuantumState object by calling the\n        constructor of the base Statevector class from Qiskit. It also calculates\n        and stores the number of qubits in the quantum state.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._num_of_qubit = int(np.log2(len(self._data)))\n\n    @property\n    def num_of_qubit(self) -&gt; int:\n        \"\"\"Get the number of qubits in the quantum state.\n\n        This property returns the total number of qubits that are currently\n        represented in the quantum state vector.\n\n        Returns:\n            int: The number of qubits in the quantum state.\n        \"\"\"\n        return self._num_of_qubit\n\n    @classmethod\n    def from_label(cls, *args: str | Tuple[complex, str]) -&gt; QuantumState:\n        \"\"\"Create a state vector from input coefficients and label strings.\n\n        Examples:\n            &gt;&gt;&gt; QuantumState.from_label(\"0\", \"1\")\n            (|0&gt; + |1&gt;)/\u221a2 QuantumState object.\n\n            &gt;&gt;&gt; QuantumState.from_label(\"00\", \"01\", \"10\", \"11\")\n            (|00&gt; + |01&gt; + |10&gt; + |11&gt;)/2 = |++&gt; QuantumState object.\n\n            &gt;&gt;&gt; QuantumState.from_label(\"+\", (-1, \"-\"))\n            (|+&gt; - |-&gt;)/\u221a2 QuantumState object.\n\n            &gt;&gt;&gt; QuantumState.from_label((2**0.5, \"0\"), \"+\", (-1, \"-\"))\n            (\u221a2|0&gt; + |+&gt; - |-&gt;)/2 = |+&gt; QuantumState object.\n\n        Args:\n            args (str | Tuple[complex, str]): Input label strings or tuples of coefficients and label strings.\n\n        Returns:\n            QuantumState: The state vector object.\n\n        Raises:\n            QiskitError: If labels contain invalid characters or if labels have different numbers of qubits.\n        \"\"\"\n        # Separate the input into coefficients and labels\n        coefficients: List[complex] = []\n        labels: List[str] = []\n        for i, arg in enumerate(args):\n            if isinstance(arg, tuple):  # Check if the input is a tuple of coefficient and label or just a label\n                coefficients.append(arg[0])\n                labels.append(arg[1])\n            else:\n                coefficients.append(1.0)\n                labels.append(arg)\n\n            if not Ket.check_valid(labels[i]):\n                raise QiskitError(\"Invalid label string.\")\n\n            if len(labels[0]) != len(labels[i]):\n                raise QiskitError(\"Each label's number of qubits must be the same.\")\n\n            labels[i] = Ket.to_qiskit_notation(labels[i])  # Convert the label to qiskit notation\n\n        # Create the state vector based on the input\n        state_sv1: Statevector = super().from_label(labels[0]) * coefficients[0]\n        for coefficient, label in zip(coefficients[1:], labels[1:]):\n            state_sv1 += super().from_label(label) * coefficient\n\n        state_sv1 /= state_sv1.trace() ** 0.5  # Normalize the state\n        return QuantumState(state_sv1)\n\n    def entropy(self) -&gt; float:\n        \"\"\"Calculate and return the Shannon  entropy of the quantum state.\n\n        The Shannon  entropy is a measure of the quantum state's uncertainty or mixedness.\n\n        Returns:\n            float: The Shannon  entropy of the quantum state, calculated in base 2.\n        \"\"\"\n        return stats.entropy(self.probabilities(), base=2)  # type: ignore\n\n    def evolve(\n        self, other: Operator | QuantumCircuit | Instruction | QuantumOperation, qargs: list[int] | None = None\n    ) -&gt; QuantumState:\n        \"\"\"Evolve the quantum state using a specified operator.\n\n        This method applies the given operator to the quantum state, evolving it\n        according to the operator's effect.\n\n        Args:\n            other (Operator | QuantumCircuit | Instruction | QuantumOperation):\n                The operator used to evolve the quantum state.\n            qargs (list[int] | None, optional): A list of subsystem positions of\n                the QuantumState to apply the operator on. Defaults to None.\n\n        Returns:\n            QuantumState: The quantum state after evolution.\n\n        Raises:\n            QiskitError: If the operator dimension does not match the specified\n                quantum state subsystem dimensions.\n        \"\"\"\n        reversed_sv1: Statevector = super().reverse_qargs()\n        evolved_sv1: Statevector = Statevector.evolve(reversed_sv1, other, qargs).reverse_qargs()\n        return QuantumState(evolved_sv1)\n\n    def apply(\n        self, other: Operator | QuantumCircuit | Instruction | QuantumOperation, qargs: list[int] | None = None\n    ) -&gt; QuantumState:\n        \"\"\"Apply a quantum operation to the quantum state.\n\n        This method is identical to the `evolve` method but provided with a different name\n        for semantic purposes.\n\n        Args:\n            other (Operator | QuantumCircuit | Instruction | QuantumOperation):\n                The operator used to evolve the quantum state.\n            qargs (list[int] | None, optional): A list of subsystem positions of\n                the QuantumState to apply the operator on. Defaults to None.\n\n        Returns:\n            QuantumState: The quantum state after evolution.\n\n        Raises:\n            QiskitError: If the operator dimension does not match the specified\n                quantum state subsystem dimensions.\n        \"\"\"\n        return self.evolve(other, qargs)\n\n    def to_matrix(self) -&gt; NDArray[np.complex128]:\n        \"\"\"Convert the quantum state vector to a column matrix representation.\n\n        This method takes the quantum state vector stored in the object and converts\n        it into a column matrix form, which can be useful for various matrix-based\n        operations and calculations.\n\n        Returns:\n            NDArray[np.complex128]: The quantum state represented as a column matrix.\n        \"\"\"\n        vector = self.data\n        matrix = vector[np.newaxis].T\n        return matrix\n\n    def draw(\n        self,\n        output: str = \"latex\",\n        target_basis: List[str] | str | None = None,\n        show_qubit_index: bool = True,\n        output_length: int = 2,\n        source: bool = False,\n    ):\n        \"\"\"Visualize the statevector.\n\n        This method provides different visualization options for the quantum state vector,\n        such as LaTeX, matrix form, or other specified formats.\n\n        Args:\n            output (str, optional): Visualization method. Defaults to \"latex\". Options include:\n                - \"matrix\": Outputs the state vector as a LaTeX formatted matrix.\n                - \"latex\": Outputs the state vector as a LaTeX formatted expression.\n            target_basis (List[str] | str | None, optional): The target basis for visualization. Defaults to None.\n            show_qubit_index (bool, optional): Whether to show qubit indices in the visualization. Defaults to True.\n            output_length (int, optional): The number of terms in each line, defined as 2^output_length.\n                                        Defaults to 2 (i.e., 4 terms per line).\n            source (bool, optional): Whether to return the latex source code for the visualization. Defaults to False.\n\n        Returns:\n            matplotlib.Figure | str | TextMatrix | IPython.display.Latex | Latex: The visualization\n                output depending on the chosen method.\n        \"\"\"\n        match output:\n            case \"matrix\":\n                return latex_drawer.matrix_to_latex(self.to_matrix(), source=source)\n            case \"latex\":\n                return latex_drawer.state_to_latex(\n                    state=self,\n                    state_basis=[\"z\"] * self.num_of_qubit,\n                    target_basis=target_basis,\n                    show_qubit_index=show_qubit_index,\n                    output_length=output_length,\n                    source=source,\n                )\n            case _:\n                raise QiskitError(\"Invalid output format.\")\n                # return super().draw(output=output, **drawer_args)\n\n    def state_after_measure(\n        self, measure_bit: List[int] | str, state_basis: List[str] | str = [], shot=100\n    ) -&gt; Tuple[List[QuantumState], List[QuantumState]]:\n        \"\"\"Obtain the quantum state after a measurement.\n\n        This method returns the quantum states resulting from measuring specified qubits in a given basis.\n        It provides two lists of quantum states: the measured states in the Z basis and the system states\n        after measurement.\n\n        Args:\n            measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list of indices or a\n                string specifying the bits.\n            state_basis (List[str] | str, optional): The basis in which to perform the measurement.\n                Defaults to an empty list.\n            shot (int, optional): The number of measurement shots to perform. Defaults to 100.\n\n        Returns:\n            Tuple[List[QuantumState], List[QuantumState]]:\n                - A list of quantum states representing the measurement results in the Z basis.\n                - A list of quantum states representing the system state after the measurement in the Z basis.\n        \"\"\"\n        z_basis_measure_state_list, z_basis_system_state_list, _, _, _, _ = self._measure(\n            measure_bit=measure_bit, state_basis=state_basis, shot=shot\n        )\n        return (z_basis_measure_state_list, z_basis_system_state_list)\n\n    def draw_measure(\n        self,\n        measure_bit: List[int] | str,\n        state_basis: List[str] | str = [],\n        show_qubit_index: bool = True,\n        output_length: int = 2,\n        source: bool = False,\n        shot: int = 100,\n    ) -&gt; str | Latex:\n        \"\"\"Visualize the measurement results of the quantum state.\n\n        This method performs a measurement on specified qubits and visualizes the\n        resulting quantum states and their measurement outcomes in a specified format.\n\n        Args:\n            measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list\n                of indices or a string specifying the bits.\n            state_basis (List[str] | str, optional): The basis in which to perform the\n                measurement. Defaults to an empty list.\n            show_qubit_index (bool, optional): Whether to show qubit indices in the\n                visualization. Defaults to True.\n            output_length (int, optional): The number of terms in each line, defined as\n                2^output_length. Defaults to 2 (i.e., 4 terms per line).\n            source (bool, optional): Whether to return the source code for the\n                visualization. Defaults to False.\n            shot (int, optional): The number of measurement shots to perform.\n                Defaults to 100.\n\n        Returns:\n            str | Latex: The visualization of the measurement results, either\n            as an image or a string representing the source code.\n\n        Raises:\n            QiskitError: If the measurement basis or bit specifications are invalid.\n        \"\"\"\n        _, _, measure_state_list, system_state_list, measure_basis, system_basis = self._measure(\n            measure_bit, state_basis, shot\n        )\n        return latex_drawer.measure_result_to_latex(\n            measure_state_list=measure_state_list,\n            system_state_list=system_state_list,\n            measure_basis=measure_basis,\n            system_basis=system_basis,\n            measure_bit=measure_bit,\n            show_qubit_index=show_qubit_index,\n            output_length=output_length,\n            source=source,\n        )\n\n    def _basis_convert(\n        self,\n        target_basis: List[str] | str = [],\n        current_basis: List[str] | str = [],\n        algorithm: str = \"global\",\n    ) -&gt; tuple[QuantumState, List[str]]:\n        \"\"\"Convert the quantum state to a target basis.\n\n        This method converts the quantum state from its current basis to a specified\n        target basis using a quantum circuit. If the target basis is not fully specified,\n        it will auto-choose the basis with minimum entropy for unspecified qubits.\n\n        Args:\n            target_basis (List[str] | str, optional): The target basis for conversion. Defaults to an empty list.\n            current_basis (List[str] | str, optional): The current basis of the quantum state.\n                Defaults to an empty list.\n            algorithm (str, optional): The algorithm used for finding the minimum entropy basis. Defaults to \"global\".\n                Options are:\n                - \"global\": Global minimum entropy basis conversion.\n                - \"local\": Local minimum entropy basis conversion.\n\n        Returns:\n            tuple[QuantumState, List[str]]: The converted quantum state and the list of the basis used for conversion.\n\n        Raises:\n            QiskitError: If the input basis is invalid or if an invalid algorithm is specified.\n        \"\"\"\n        # Default target_basis is auto choose basis with minimum entropy (basis = \"*\")\n        target_basis = list(target_basis) + [\"*\"] * (self.num_of_qubit - len(target_basis))\n        # Default current_basis is Z basis\n        current_basis = list(current_basis) + [\"z\"] * (self.num_of_qubit - len(current_basis))\n\n        # Check if input is valid\n        if re.match(R\"^[\\-\\*xyz]+$\", \"\".join(target_basis)) is None:\n            raise QiskitError(\"Invalid basis.\")\n\n        # Empty list to save auto-choose-basis index\n        auto_basis_index = []\n        # Convert basis using QuantumCircuit\n        convert_circ = QuantumOperation(self.num_of_qubit)\n        for i in range(self.num_of_qubit):\n            if target_basis[i] == current_basis[i]:\n                continue\n            if target_basis[i] == \"*\" or target_basis[i] == \"-\":\n                auto_basis_index.append(i)\n                continue\n            convert_circ._xyz_convert_circ(target_basis=target_basis[i], current_basis=current_basis[i], qubit_index=i)\n            current_basis[i] = target_basis[i]\n\n        converted_state = self.evolve(convert_circ)\n        if not auto_basis_index:\n            return (converted_state, current_basis)\n\n        # If user don't specify which basis to convert, convert basis to basis with minimum entropy\n        match algorithm:\n            case \"global\":\n                if len(auto_basis_index) &gt; 8:\n                    print(\n                        \"Notice: global minimum entropy basis convert with more then 8 qubits might take a long time.\"\n                    )\n                optimize_basis = converted_state._global_min_entropy_basis(auto_basis_index, current_basis)\n            case \"local\":\n                optimize_basis = converted_state._local_min_entropy_basis(auto_basis_index, current_basis)\n            case _:\n                raise QiskitError(\"Invalid min_entropy_basis_find_method.\")\n\n        return converted_state._basis_convert(target_basis=optimize_basis, current_basis=current_basis)\n\n    def _global_min_entropy_basis(self, auto_basis_index: List[int], current_basis: List[str]) -&gt; List[str]:\n        \"\"\"Find the basis with global minimum entropy.\n\n        This method searches for the basis configuration that minimizes the entropy\n        of the quantum state globally, by trying all possible combinations of the\n        specified bases at the auto-choose-basis indices.\n\n        Args:\n            auto_basis_index (List[int]): Indices of the qubits for which the basis\n                should be auto-chosen to minimize entropy.\n            current_basis (List[str]): The current basis of the quantum state.\n\n        Returns:\n            List[str]: The basis configuration with the global minimum entropy.\n        \"\"\"\n        num_of_auto_basis = len(auto_basis_index)\n        min_entropy = float(\"inf\")\n        min_basis = current_basis.copy()\n        try_basis = current_basis.copy()\n        for basis in itertools.product([\"z\", \"x\", \"y\"], repeat=num_of_auto_basis):  # type: ignore\n            for i in range(num_of_auto_basis):\n                try_basis[auto_basis_index[i]] = basis[i]\n                try_state = self._basis_convert(target_basis=try_basis, current_basis=current_basis)[0]\n            if (entropy := try_state.entropy()) &lt; min_entropy:\n                min_entropy = entropy\n                min_basis = try_basis.copy()\n        return min_basis\n\n    def _local_min_entropy_basis(self, auto_basis_index: List[int], current_basis: List[str]) -&gt; List[str]:\n        \"\"\"Find the basis with local minimum entropy.\n\n        This method searches for the basis configuration that locally minimizes the entropy\n        of the quantum state by iteratively selecting the best basis for each qubit.\n\n        Args:\n            auto_basis_index (List[int]): Indices of the qubits for which the basis should be auto-chosen to\n                minimize entropy.\n            current_basis (List[str]): The current basis of the quantum state.\n\n        Returns:\n            List[str]: The basis configuration with the local minimum entropy.\n        \"\"\"\n        # Step 1: Change all auto-choose-basis to y, e.g. [-, -, -, -] -&gt; [z, z, z, z], calculate entropy\n        # Step 2,3: Same as Step 1, but with x-basis and y-basis\n        # Step 4: from Step 1 to 3, choose the basis with minimum entropy.\n        min_entropy = float(\"inf\")\n        min_basis = current_basis.copy()\n        for basis in [\"z\", \"x\", \"y\"]:\n            try_basis = min_basis.copy()\n            for i in auto_basis_index:\n                try_basis[i] = basis\n            try_state = self._basis_convert(target_basis=try_basis, current_basis=current_basis)[0]\n            if (entropy := try_state.entropy()) &lt; min_entropy:\n                min_entropy = entropy\n                min_basis = try_basis.copy()\n\n        # Step 1: Change the first auto-choose-basis to y, e.g. [-, -, -, -] -&gt; [y, -, -, -], calculate entropy,\n        # Step 2,3: Same as Step 1, but with x-basis and z-basis\n        # Step 4: from Step 1 to 3, choose the basis with minimum entropy.\n        # Step 5: Repeat Step 1 to 4 for the second auto-choose-basis, and so on. (greedy)\n        # e.g. [-, -, -, -] -&gt; [x, -, -, -] -&gt; [x, z, -, -] -&gt; [x, z, y, -] -&gt; [x, z, y, z]\n        for i in auto_basis_index:\n            try_basis = min_basis.copy()\n            for basis in [\"y\", \"x\", \"z\"]:\n                try_basis[i] = basis\n                try_state = self._basis_convert(target_basis=try_basis, current_basis=current_basis)[0]\n                if (entropy_tmp := try_state.entropy()) &lt; min_entropy:\n                    min_entropy = entropy_tmp\n                    min_basis[i] = basis\n        return min_basis\n\n    def _measure(\n        self, measure_bit: List[int] | str, state_basis: List[str] | str = [], shot=100\n    ) -&gt; Tuple[List[QuantumState], List[QuantumState], List[QuantumState], List[QuantumState], List[str], List[str]]:\n        \"\"\"Perform a measurement on the quantum state.\n\n        This method measures the specified qubits in the given basis and returns the\n        resulting quantum states and measurement outcomes.\n\n        Args:\n            measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list\n                of indices or a string specifying the bits.\n            state_basis (List[str] | str, optional): The basis in which to perform the\n                measurement. Defaults to an empty list.\n            shot (int, optional): The number of measurement shots to perform. Defaults to 100.\n\n        Returns:\n            Tuple[List[QuantumState], List[QuantumState], List[QuantumState], List[QuantumState], List[str], List[str]]:\n                - z_basis_measure_state_list: Measurement states in the Z basis.\n                - z_basis_system_state_list: System states in the Z basis.\n                - measure_state_list: Measurement states in the original basis.\n                - system_state_list: System states in the original basis.\n                - measure_basis: The basis used for the measurement.\n                - system_basis: The system basis after conversion.\n        \"\"\"\n        if isinstance(measure_bit, str):\n            measure_bit = [int(i) for i in measure_bit]\n\n        converted_state, system_basis = self._basis_convert(\n            target_basis=state_basis, current_basis=[\"z\"] * self.num_of_qubit\n        )\n\n        # crate empty list for output\n        z_basis_measure_state_list = [None] * 2 ** len(measure_bit)\n        z_basis_system_state_list = [None] * 2 ** len(measure_bit)\n        measure_state_list = [None] * 2 ** len(measure_bit)\n        system_state_list = [None] * 2 ** len(measure_bit)\n        for _ in range(shot):\n            measure_ket: str\n            system_state: Statevector\n            measure_ket, system_state = Statevector(converted_state.data).measure(qargs=measure_bit)  # type: ignore\n            measure_ket = measure_ket[::-1]  # REVERSE the order of qubits to fit textbook notation\n            if measure_state_list[int(measure_ket, 2)] is None:\n                measure_basis = []\n                for i in measure_bit:\n                    measure_basis.append(system_basis[i])\n\n                basis_convert_measure_ket = \"\"\n                for b, k in zip(measure_basis, measure_ket):\n                    match b:\n                        case \"z\":\n                            basis_convert_measure_ket += Ket.z1 if int(k) else Ket.z0\n                        case \"x\":\n                            basis_convert_measure_ket += Ket.x1 if int(k) else Ket.x0\n                        case \"y\":\n                            basis_convert_measure_ket += Ket.y1 if int(k) else Ket.y0\n\n                measure_state_z_basis = self.from_label(basis_convert_measure_ket)\n                system_state = QuantumState(system_state)\n\n                z_basis_measure_state_list[int(measure_ket, 2)] = measure_state_z_basis\n                z_basis_system_state_list[int(measure_ket, 2)] = system_state._basis_convert(\n                    target_basis=[\"z\"] * self.num_of_qubit, current_basis=system_basis\n                )[0]\n                measure_state_list[int(measure_ket, 2)] = measure_state_z_basis._basis_convert(\n                    target_basis=measure_basis\n                )[0]\n                system_state_list[int(measure_ket, 2)] = system_state\n\n        return (\n            z_basis_measure_state_list,\n            z_basis_system_state_list,\n            measure_state_list,\n            system_state_list,\n            measure_basis,\n            system_basis,\n        )\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.num_of_qubit","title":"<code>num_of_qubit: int</code>  <code>property</code>","text":"<p>Get the number of qubits in the quantum state.</p> <p>This property returns the total number of qubits that are currently represented in the quantum state vector.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of qubits in the quantum state.</p>"},{"location":"reference/#QIRT.QuantumState.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize a QuantumState object.</p> <p>This constructor initializes the QuantumState object by calling the constructor of the base Statevector class from Qiskit. It also calculates and stores the number of qubits in the quantum state.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize a QuantumState object.\n\n    This constructor initializes the QuantumState object by calling the\n    constructor of the base Statevector class from Qiskit. It also calculates\n    and stores the number of qubits in the quantum state.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._num_of_qubit = int(np.log2(len(self._data)))\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.apply","title":"<code>apply(other, qargs=None)</code>","text":"<p>Apply a quantum operation to the quantum state.</p> <p>This method is identical to the <code>evolve</code> method but provided with a different name for semantic purposes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Operator | QuantumCircuit | Instruction | QuantumOperation</code> <p>The operator used to evolve the quantum state.</p> required <code>qargs</code> <code>list[int] | None</code> <p>A list of subsystem positions of the QuantumState to apply the operator on. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QuantumState</code> <code>QuantumState</code> <p>The quantum state after evolution.</p> <p>Raises:</p> Type Description <code>QiskitError</code> <p>If the operator dimension does not match the specified quantum state subsystem dimensions.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def apply(\n    self, other: Operator | QuantumCircuit | Instruction | QuantumOperation, qargs: list[int] | None = None\n) -&gt; QuantumState:\n    \"\"\"Apply a quantum operation to the quantum state.\n\n    This method is identical to the `evolve` method but provided with a different name\n    for semantic purposes.\n\n    Args:\n        other (Operator | QuantumCircuit | Instruction | QuantumOperation):\n            The operator used to evolve the quantum state.\n        qargs (list[int] | None, optional): A list of subsystem positions of\n            the QuantumState to apply the operator on. Defaults to None.\n\n    Returns:\n        QuantumState: The quantum state after evolution.\n\n    Raises:\n        QiskitError: If the operator dimension does not match the specified\n            quantum state subsystem dimensions.\n    \"\"\"\n    return self.evolve(other, qargs)\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.draw","title":"<code>draw(output='latex', target_basis=None, show_qubit_index=True, output_length=2, source=False)</code>","text":"<p>Visualize the statevector.</p> <p>This method provides different visualization options for the quantum state vector, such as LaTeX, matrix form, or other specified formats.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>Visualization method. Defaults to \"latex\". Options include: - \"matrix\": Outputs the state vector as a LaTeX formatted matrix. - \"latex\": Outputs the state vector as a LaTeX formatted expression.</p> <code>'latex'</code> <code>target_basis</code> <code>List[str] | str | None</code> <p>The target basis for visualization. Defaults to None.</p> <code>None</code> <code>show_qubit_index</code> <code>bool</code> <p>Whether to show qubit indices in the visualization. Defaults to True.</p> <code>True</code> <code>output_length</code> <code>int</code> <p>The number of terms in each line, defined as 2^output_length.                         Defaults to 2 (i.e., 4 terms per line).</p> <code>2</code> <code>source</code> <code>bool</code> <p>Whether to return the latex source code for the visualization. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>matplotlib.Figure | str | TextMatrix | IPython.display.Latex | Latex: The visualization output depending on the chosen method.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def draw(\n    self,\n    output: str = \"latex\",\n    target_basis: List[str] | str | None = None,\n    show_qubit_index: bool = True,\n    output_length: int = 2,\n    source: bool = False,\n):\n    \"\"\"Visualize the statevector.\n\n    This method provides different visualization options for the quantum state vector,\n    such as LaTeX, matrix form, or other specified formats.\n\n    Args:\n        output (str, optional): Visualization method. Defaults to \"latex\". Options include:\n            - \"matrix\": Outputs the state vector as a LaTeX formatted matrix.\n            - \"latex\": Outputs the state vector as a LaTeX formatted expression.\n        target_basis (List[str] | str | None, optional): The target basis for visualization. Defaults to None.\n        show_qubit_index (bool, optional): Whether to show qubit indices in the visualization. Defaults to True.\n        output_length (int, optional): The number of terms in each line, defined as 2^output_length.\n                                    Defaults to 2 (i.e., 4 terms per line).\n        source (bool, optional): Whether to return the latex source code for the visualization. Defaults to False.\n\n    Returns:\n        matplotlib.Figure | str | TextMatrix | IPython.display.Latex | Latex: The visualization\n            output depending on the chosen method.\n    \"\"\"\n    match output:\n        case \"matrix\":\n            return latex_drawer.matrix_to_latex(self.to_matrix(), source=source)\n        case \"latex\":\n            return latex_drawer.state_to_latex(\n                state=self,\n                state_basis=[\"z\"] * self.num_of_qubit,\n                target_basis=target_basis,\n                show_qubit_index=show_qubit_index,\n                output_length=output_length,\n                source=source,\n            )\n        case _:\n            raise QiskitError(\"Invalid output format.\")\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.draw_measure","title":"<code>draw_measure(measure_bit, state_basis=[], show_qubit_index=True, output_length=2, source=False, shot=100)</code>","text":"<p>Visualize the measurement results of the quantum state.</p> <p>This method performs a measurement on specified qubits and visualizes the resulting quantum states and their measurement outcomes in a specified format.</p> <p>Parameters:</p> Name Type Description Default <code>measure_bit</code> <code>List[int] | str</code> <p>The bits (qubits) to measure. Can be a list of indices or a string specifying the bits.</p> required <code>state_basis</code> <code>List[str] | str</code> <p>The basis in which to perform the measurement. Defaults to an empty list.</p> <code>[]</code> <code>show_qubit_index</code> <code>bool</code> <p>Whether to show qubit indices in the visualization. Defaults to True.</p> <code>True</code> <code>output_length</code> <code>int</code> <p>The number of terms in each line, defined as 2^output_length. Defaults to 2 (i.e., 4 terms per line).</p> <code>2</code> <code>source</code> <code>bool</code> <p>Whether to return the source code for the visualization. Defaults to False.</p> <code>False</code> <code>shot</code> <code>int</code> <p>The number of measurement shots to perform. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>str | Latex</code> <p>str | Latex: The visualization of the measurement results, either</p> <code>str | Latex</code> <p>as an image or a string representing the source code.</p> <p>Raises:</p> Type Description <code>QiskitError</code> <p>If the measurement basis or bit specifications are invalid.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def draw_measure(\n    self,\n    measure_bit: List[int] | str,\n    state_basis: List[str] | str = [],\n    show_qubit_index: bool = True,\n    output_length: int = 2,\n    source: bool = False,\n    shot: int = 100,\n) -&gt; str | Latex:\n    \"\"\"Visualize the measurement results of the quantum state.\n\n    This method performs a measurement on specified qubits and visualizes the\n    resulting quantum states and their measurement outcomes in a specified format.\n\n    Args:\n        measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list\n            of indices or a string specifying the bits.\n        state_basis (List[str] | str, optional): The basis in which to perform the\n            measurement. Defaults to an empty list.\n        show_qubit_index (bool, optional): Whether to show qubit indices in the\n            visualization. Defaults to True.\n        output_length (int, optional): The number of terms in each line, defined as\n            2^output_length. Defaults to 2 (i.e., 4 terms per line).\n        source (bool, optional): Whether to return the source code for the\n            visualization. Defaults to False.\n        shot (int, optional): The number of measurement shots to perform.\n            Defaults to 100.\n\n    Returns:\n        str | Latex: The visualization of the measurement results, either\n        as an image or a string representing the source code.\n\n    Raises:\n        QiskitError: If the measurement basis or bit specifications are invalid.\n    \"\"\"\n    _, _, measure_state_list, system_state_list, measure_basis, system_basis = self._measure(\n        measure_bit, state_basis, shot\n    )\n    return latex_drawer.measure_result_to_latex(\n        measure_state_list=measure_state_list,\n        system_state_list=system_state_list,\n        measure_basis=measure_basis,\n        system_basis=system_basis,\n        measure_bit=measure_bit,\n        show_qubit_index=show_qubit_index,\n        output_length=output_length,\n        source=source,\n    )\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.entropy","title":"<code>entropy()</code>","text":"<p>Calculate and return the Shannon  entropy of the quantum state.</p> <p>The Shannon  entropy is a measure of the quantum state's uncertainty or mixedness.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Shannon  entropy of the quantum state, calculated in base 2.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def entropy(self) -&gt; float:\n    \"\"\"Calculate and return the Shannon  entropy of the quantum state.\n\n    The Shannon  entropy is a measure of the quantum state's uncertainty or mixedness.\n\n    Returns:\n        float: The Shannon  entropy of the quantum state, calculated in base 2.\n    \"\"\"\n    return stats.entropy(self.probabilities(), base=2)  # type: ignore\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.evolve","title":"<code>evolve(other, qargs=None)</code>","text":"<p>Evolve the quantum state using a specified operator.</p> <p>This method applies the given operator to the quantum state, evolving it according to the operator's effect.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Operator | QuantumCircuit | Instruction | QuantumOperation</code> <p>The operator used to evolve the quantum state.</p> required <code>qargs</code> <code>list[int] | None</code> <p>A list of subsystem positions of the QuantumState to apply the operator on. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QuantumState</code> <code>QuantumState</code> <p>The quantum state after evolution.</p> <p>Raises:</p> Type Description <code>QiskitError</code> <p>If the operator dimension does not match the specified quantum state subsystem dimensions.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def evolve(\n    self, other: Operator | QuantumCircuit | Instruction | QuantumOperation, qargs: list[int] | None = None\n) -&gt; QuantumState:\n    \"\"\"Evolve the quantum state using a specified operator.\n\n    This method applies the given operator to the quantum state, evolving it\n    according to the operator's effect.\n\n    Args:\n        other (Operator | QuantumCircuit | Instruction | QuantumOperation):\n            The operator used to evolve the quantum state.\n        qargs (list[int] | None, optional): A list of subsystem positions of\n            the QuantumState to apply the operator on. Defaults to None.\n\n    Returns:\n        QuantumState: The quantum state after evolution.\n\n    Raises:\n        QiskitError: If the operator dimension does not match the specified\n            quantum state subsystem dimensions.\n    \"\"\"\n    reversed_sv1: Statevector = super().reverse_qargs()\n    evolved_sv1: Statevector = Statevector.evolve(reversed_sv1, other, qargs).reverse_qargs()\n    return QuantumState(evolved_sv1)\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.from_label","title":"<code>from_label(*args)</code>  <code>classmethod</code>","text":"<p>Create a state vector from input coefficients and label strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; QuantumState.from_label(\"0\", \"1\")\n(|0&gt; + |1&gt;)/\u221a2 QuantumState object.\n</code></pre> <pre><code>&gt;&gt;&gt; QuantumState.from_label(\"00\", \"01\", \"10\", \"11\")\n(|00&gt; + |01&gt; + |10&gt; + |11&gt;)/2 = |++&gt; QuantumState object.\n</code></pre> <pre><code>&gt;&gt;&gt; QuantumState.from_label(\"+\", (-1, \"-\"))\n(|+&gt; - |-&gt;)/\u221a2 QuantumState object.\n</code></pre> <pre><code>&gt;&gt;&gt; QuantumState.from_label((2**0.5, \"0\"), \"+\", (-1, \"-\"))\n(\u221a2|0&gt; + |+&gt; - |-&gt;)/2 = |+&gt; QuantumState object.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str | Tuple[complex, str]</code> <p>Input label strings or tuples of coefficients and label strings.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>QuantumState</code> <code>QuantumState</code> <p>The state vector object.</p> <p>Raises:</p> Type Description <code>QiskitError</code> <p>If labels contain invalid characters or if labels have different numbers of qubits.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>@classmethod\ndef from_label(cls, *args: str | Tuple[complex, str]) -&gt; QuantumState:\n    \"\"\"Create a state vector from input coefficients and label strings.\n\n    Examples:\n        &gt;&gt;&gt; QuantumState.from_label(\"0\", \"1\")\n        (|0&gt; + |1&gt;)/\u221a2 QuantumState object.\n\n        &gt;&gt;&gt; QuantumState.from_label(\"00\", \"01\", \"10\", \"11\")\n        (|00&gt; + |01&gt; + |10&gt; + |11&gt;)/2 = |++&gt; QuantumState object.\n\n        &gt;&gt;&gt; QuantumState.from_label(\"+\", (-1, \"-\"))\n        (|+&gt; - |-&gt;)/\u221a2 QuantumState object.\n\n        &gt;&gt;&gt; QuantumState.from_label((2**0.5, \"0\"), \"+\", (-1, \"-\"))\n        (\u221a2|0&gt; + |+&gt; - |-&gt;)/2 = |+&gt; QuantumState object.\n\n    Args:\n        args (str | Tuple[complex, str]): Input label strings or tuples of coefficients and label strings.\n\n    Returns:\n        QuantumState: The state vector object.\n\n    Raises:\n        QiskitError: If labels contain invalid characters or if labels have different numbers of qubits.\n    \"\"\"\n    # Separate the input into coefficients and labels\n    coefficients: List[complex] = []\n    labels: List[str] = []\n    for i, arg in enumerate(args):\n        if isinstance(arg, tuple):  # Check if the input is a tuple of coefficient and label or just a label\n            coefficients.append(arg[0])\n            labels.append(arg[1])\n        else:\n            coefficients.append(1.0)\n            labels.append(arg)\n\n        if not Ket.check_valid(labels[i]):\n            raise QiskitError(\"Invalid label string.\")\n\n        if len(labels[0]) != len(labels[i]):\n            raise QiskitError(\"Each label's number of qubits must be the same.\")\n\n        labels[i] = Ket.to_qiskit_notation(labels[i])  # Convert the label to qiskit notation\n\n    # Create the state vector based on the input\n    state_sv1: Statevector = super().from_label(labels[0]) * coefficients[0]\n    for coefficient, label in zip(coefficients[1:], labels[1:]):\n        state_sv1 += super().from_label(label) * coefficient\n\n    state_sv1 /= state_sv1.trace() ** 0.5  # Normalize the state\n    return QuantumState(state_sv1)\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.state_after_measure","title":"<code>state_after_measure(measure_bit, state_basis=[], shot=100)</code>","text":"<p>Obtain the quantum state after a measurement.</p> <p>This method returns the quantum states resulting from measuring specified qubits in a given basis. It provides two lists of quantum states: the measured states in the Z basis and the system states after measurement.</p> <p>Parameters:</p> Name Type Description Default <code>measure_bit</code> <code>List[int] | str</code> <p>The bits (qubits) to measure. Can be a list of indices or a string specifying the bits.</p> required <code>state_basis</code> <code>List[str] | str</code> <p>The basis in which to perform the measurement. Defaults to an empty list.</p> <code>[]</code> <code>shot</code> <code>int</code> <p>The number of measurement shots to perform. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>Tuple[List[QuantumState], List[QuantumState]]</code> <p>Tuple[List[QuantumState], List[QuantumState]]: - A list of quantum states representing the measurement results in the Z basis. - A list of quantum states representing the system state after the measurement in the Z basis.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def state_after_measure(\n    self, measure_bit: List[int] | str, state_basis: List[str] | str = [], shot=100\n) -&gt; Tuple[List[QuantumState], List[QuantumState]]:\n    \"\"\"Obtain the quantum state after a measurement.\n\n    This method returns the quantum states resulting from measuring specified qubits in a given basis.\n    It provides two lists of quantum states: the measured states in the Z basis and the system states\n    after measurement.\n\n    Args:\n        measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list of indices or a\n            string specifying the bits.\n        state_basis (List[str] | str, optional): The basis in which to perform the measurement.\n            Defaults to an empty list.\n        shot (int, optional): The number of measurement shots to perform. Defaults to 100.\n\n    Returns:\n        Tuple[List[QuantumState], List[QuantumState]]:\n            - A list of quantum states representing the measurement results in the Z basis.\n            - A list of quantum states representing the system state after the measurement in the Z basis.\n    \"\"\"\n    z_basis_measure_state_list, z_basis_system_state_list, _, _, _, _ = self._measure(\n        measure_bit=measure_bit, state_basis=state_basis, shot=shot\n    )\n    return (z_basis_measure_state_list, z_basis_system_state_list)\n</code></pre>"},{"location":"reference/#QIRT.QuantumState.to_matrix","title":"<code>to_matrix()</code>","text":"<p>Convert the quantum state vector to a column matrix representation.</p> <p>This method takes the quantum state vector stored in the object and converts it into a column matrix form, which can be useful for various matrix-based operations and calculations.</p> <p>Returns:</p> Type Description <code>NDArray[complex128]</code> <p>NDArray[np.complex128]: The quantum state represented as a column matrix.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def to_matrix(self) -&gt; NDArray[np.complex128]:\n    \"\"\"Convert the quantum state vector to a column matrix representation.\n\n    This method takes the quantum state vector stored in the object and converts\n    it into a column matrix form, which can be useful for various matrix-based\n    operations and calculations.\n\n    Returns:\n        NDArray[np.complex128]: The quantum state represented as a column matrix.\n    \"\"\"\n    vector = self.data\n    matrix = vector[np.newaxis].T\n    return matrix\n</code></pre>"}]}