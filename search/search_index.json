{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Quantum Information Research Toolkit Documentation","text":"<p>Welcome to the documentation for the Quantum Information Research Toolkit (QIRT), your comprehensive guide to leveraging quantum computing for research and development. This toolkit provides various functionalities to help you create, simulate, and analyze quantum circuits and states.</p>"},{"location":"#documentation-overview","title":"Documentation overview","text":"<ol> <li>Tutorials<ul> <li>Learn the basics usage of QIRT with hands-on examples.</li> </ul> </li> <li>How-To Guides<ul> <li>Step-by-step instructions for specific tasks and use cases.</li> </ul> </li> <li>Reference<ul> <li>Detailed descriptions of all QIRT functions, classes, and modules.</li> </ul> </li> </ol>"},{"location":"#getting-started","title":"Getting started","text":"<p>If you're new to QIRT, we recommend starting with our Tutorials to get an overview of the toolkit's capabilities and how to use them effectively.</p> <p>For specific tasks or problems, check out our How-To Guides. These guides provide practical solutions and examples for common use cases.</p> <p>Finally, our Reference section offers in-depth documentation on all available functions, classes, and modules within QIRT. Use this section as a technical resource for detailed information on QIRT's API.</p>"},{"location":"#about-qirt","title":"About QIRT","text":"<p>The Quantum Information Research Toolkit is designed to support researchers, educators, and developers working in the field of quantum information. Our goal is to provide researchers with a convenient computational tool to facilitate research and development in quantum computing. QIRT is built on top of Qiskit, a widely-used quantum computing framework, and provides additional functionalities to enhance your quantum computing experience.</p> <p>Thank you for using the Quantum Information Research Toolkit. We hope you find it valuable in your quantum computing endeavors.</p>"},{"location":"how_to_guides/","title":"How-to Guides","text":"<p>Welcome to the QIRT How-to Guides. These guides provide detailed instructions on how to perform various tasks using QIRT. Whether you're new to quantum computing or an experienced practitioner, these guides will help you make the most of QIRT's capabilities.</p>"},{"location":"how_to_guides/#contents","title":"Contents","text":"<p>Each guide provides step-by-step instructions and examples to help you master different aspects of QIRT:</p> <ul> <li>Create Quantum States: Explore the flexible <code>from_label</code> method to create quantum states using ket notation with coefficients.</li> <li>Visualize Quantum States: Learn how to use QIRT's powerful <code>draw</code> method to represent quantum states in various formats.</li> <li>Create Quantum Circuits: Learn advanced techniques for creating quantum circuits, including method chaining and adding custom unitary operators.</li> <li>Qubit Measurement: Dive deep into the <code>draw_measurement</code> function for complex quantum state measurements.</li> <li>Customize Ket Notation: Discover how to adapt QIRT's ket notation to your preferences using the configuration file.</li> </ul> <p>These guides are designed to take you from basic concepts to advanced techniques, helping you leverage the full power of QIRT in your quantum computing projects. Feel free to explore them in any order based on your specific needs and interests.</p>"},{"location":"how_to_guides/create_circuits/","title":"Creating Quantum Circuits with Matrices and Qiskit provides gate","text":"<p>This guide covers advanced techniques for creating quantum circuits in QIRT, including method chaining and adding custom unitary operators.</p>"},{"location":"how_to_guides/create_circuits/#method-chaining","title":"Method Chaining","text":"<p>QIRT's <code>QuantumCircuit</code> class supports method chaining, which allows you to build circuits more concisely. Here's how you can create a Bell state circuit using method chaining:</p> <pre><code>from QIRT import QuantumCircuit\n\n# Create a two-qubit quantum circuit and add gates using method chaining\ncircuit = QuantumCircuit(2).h(0).cx(0, 1)\n\n# Visualize the circuit\ncircuit.draw()\n</code></pre> <p>&gt;&gt; Output:</p> <p></p> <p>Method chaining can make your code cleaner and more readable, especially for constructing more complex circuits.</p>"},{"location":"how_to_guides/create_circuits/#adding-custom-unitary-operators","title":"Adding Custom Unitary Operators","text":"<p>QIRT allows you to add custom unitary operators to your quantum circuits using the <code>unitary</code> method. This is particularly useful when you want to apply a specific unitary transformation that isn't available as a built-in gate.</p>"},{"location":"how_to_guides/create_circuits/#example-adding-a-custom-xor-gate","title":"Example: Adding a Custom XOR Gate","text":"<p>Let's add a custom XOR gate to our circuit:</p> <pre><code>from QIRT import QuantumCircuit\nimport numpy as np\n\n# Create a quantum circuit\ncirc = QuantumCircuit(2)\n\n# Add a custom XOR gate\ncirc.unitary(matrix=[[0,1],[1,0]], qubits=[0], label='XOR')\n\n# Visualize the circuit\ncirc.draw()\n</code></pre> <p>This adds a custom XOR gate (which is equivalent to a Pauli-X or NOT gate) to the first qubit of our circuit.</p> <p>The <code>unitary</code> method allows you to apply any custom unitary matrix to specified qubits. The <code>matrix</code> parameter takes the unitary matrix, <code>qubits</code> specifies which qubits to apply the gate to, and <code>label</code> allows you to give a name to your custom gate.</p>"},{"location":"how_to_guides/create_circuits/#finding-more-quantum-gates","title":"Finding More Quantum Gates","text":"<p>QIRT is built on top of Qiskit, which is a comprehensive and widely-used framework for quantum computing. As such, QIRT provides support for many different quantum gates. To explore all available gates and their usage, you can refer to the Qiskit Circuit Library.</p>"},{"location":"how_to_guides/create_states/","title":"Creating Quantum States with Ket Notation and Matrices","text":"<p>QIRT provides multiple powerful methods to create quantum states. This guide covers advanced techniques for state creation, including using coefficients, different bases, and creating states from matrices.</p>"},{"location":"how_to_guides/create_states/#creating-states-from-bra-ket-notation","title":"Creating States from Bra-Ket Notation","text":""},{"location":"how_to_guides/create_states/#basic-usage","title":"Basic Usage","text":"<p>To create a simple quantum state, you can use string labels:</p> <pre><code>from QIRT import QuantumState\n\n# Create an equal superposition of |0\u27e9 and |1\u27e9\nstate = QuantumState.from_label(\"0\", \"1\")\nstate.draw(target_basis=\"z\")\n</code></pre> <p>Output: $ \\frac{\\sqrt{2}}{2}|\\texttt{0}\\rangle_{0} +\\frac{\\sqrt{2}}{2}|\\texttt{1}\\rangle_{0} $</p>"},{"location":"how_to_guides/create_states/#multi-qubit-states","title":"Multi-Qubit States","text":"<p>You can create multi-qubit states by providing longer string labels:</p> <pre><code># Create an equal superposition of all two-qubit states\nstate = QuantumState.from_label(\"00\", \"01\", \"10\", \"11\")\nstate.draw(target_basis=\"zz\")\n</code></pre> <p>Output: $ \\frac{1}{2}|\\texttt{00}\\rangle_{01} +\\frac{1}{2}|\\texttt{01}\\rangle_{01} +\\frac{1}{2}|\\texttt{10}\\rangle_{01} +\\frac{1}{2}|\\texttt{11}\\rangle_{01} $</p>"},{"location":"how_to_guides/create_states/#using-different-bases","title":"Using Different Bases","text":"<p>QIRT supports different bases (X, Y, Z) in state creation:</p> <pre><code># Create a state in the X-basis\nstate = QuantumState.from_label(\"+\", \"-\")\nstate.draw(target_basis=\"x\")\n</code></pre> <p>Output: $ \\frac{\\sqrt{2}}{2}|\\texttt{+}\\rangle_{0} + \\frac{\\sqrt{2}}{2}|\\texttt{-}\\rangle_{0} $</p>"},{"location":"how_to_guides/create_states/#states-with-coefficients","title":"States with Coefficients","text":"<p>You can specify complex coefficients for each ket:</p> <pre><code># Create a state with specific coefficients\nstate = QuantumState.from_label(\"0\", (-1, \"1\"))\nstate.draw(target_basis=\"z\")\n</code></pre> <p>Output: $ \\frac{\\sqrt{2}}{2}|\\texttt{0}\\rangle_{0} - \\frac{\\sqrt{2}}{2}|\\texttt{1}\\rangle_{0} $</p> <pre><code># Create a state with complex coefficients\nstate = QuantumState.from_label(\"0\", (1j, \"1\"))\nstate.draw(target_basis=\"z\")\n</code></pre> <p>Output: $ \\frac{\\sqrt{2}}{2}|\\texttt{0}\\rangle_{0} +\\frac{\\sqrt{2} i}{2}|\\texttt{1}\\rangle_{0} $</p>"},{"location":"how_to_guides/create_states/#creating-states-from-matrices","title":"Creating States from Matrices","text":"<p>QIRT also allows you to create quantum states by directly providing the state vector as a list or numpy array.</p> <pre><code>import numpy as np\nfrom QIRT import QuantumState\n\n# Create a quantum state |00&gt; from matrix\nstate_00 = QuantumState([1, 0, 0, 0])\n\n# Create a quantum state |11&gt; from numpy array\nstate_11 = QuantumState(np.array([0, 0, 0, 1]))\n\n# Create a Bell state (|00&gt; + |11&gt;) / sqrt(2)\nbell_state = QuantumState([1/np.sqrt(2), 0, 0, 1/np.sqrt(2)])\n\n# Visualize the Bell state\nbell_state.draw()\n</code></pre> <p>Output: $ \\frac{\\sqrt{2}}{2}|\\texttt{00}\\rangle_{01} + \\frac{\\sqrt{2}}{2}|\\texttt{11}\\rangle_{01} $</p>"},{"location":"how_to_guides/create_states/#notes-on-usage","title":"Notes on Usage","text":"<ul> <li>Coefficients can be real or complex numbers.</li> <li>The method supports various notations: computational basis (0,1), X-basis (+,-), and Y-basis (i,j).</li> <li>For multi-qubit states, use concatenated labels (e.g., \"00\", \"01\").</li> <li>The resulting state is always normalized.</li> <li>When creating states from matrices, ensure the vector is normalized and has the correct dimension (2^n for n qubits).</li> </ul>"},{"location":"how_to_guides/customize_ket_notation/","title":"Customizing Ket Notation with Configuration File","text":"<p>QIRT allows you to customize the ket notation using a configuration file. This feature enables you to adapt the notation to your preferences or to match specific conventions in your work.</p>"},{"location":"how_to_guides/customize_ket_notation/#configuration-file-location","title":"Configuration File Location","text":"<p>The configuration file is located at:</p> <pre><code>~/.QIRT/config.ini\n</code></pre> <p>in your home directory.</p>"},{"location":"how_to_guides/customize_ket_notation/#default-configuration","title":"Default Configuration","text":"<p>Here's an example of the default configuration:</p> <pre><code>[ket]\nz0 = 0\nz1 = 1\nx0 = +\nx1 = -\ny0 = i\ny1 = j\n</code></pre> <p>This configuration defines how different basis states are represented:</p> <ul> <li><code>z0</code> and <code>z1</code> represent the computational basis states</li> <li><code>x0</code> and <code>x1</code> represent the X-basis states</li> <li><code>y0</code> and <code>y1</code> represent the Y-basis states</li> </ul>"},{"location":"how_to_guides/customize_ket_notation/#customizing-the-notation","title":"Customizing the Notation","text":"<p>To customize the ket notation:</p> <ol> <li>Open the <code>config.ini</code> file in a text editor.</li> <li>Modify the values for each basis state as desired.</li> <li>Save the file.</li> </ol> <p>For example, if you prefer to use \"r\" and \"l\" for the Y-basis states, you could modify the configuration like this:</p> <pre><code>[ket]\nz0 = 0\nz1 = 1\nx0 = +\nx1 = -\ny0 = r\ny1 = l\n</code></pre>"},{"location":"how_to_guides/customize_ket_notation/#applying-changes","title":"Applying Changes","text":"<p>After making changes to the configuration file, you must restart your Jupyter kernel or Python interpreter for the changes to take effect. This ensures that QIRT loads the updated configuration properly.</p>"},{"location":"how_to_guides/customize_ket_notation/#usage-example","title":"Usage Example","text":"<p>After customizing the notation, your quantum states will be represented using the new notation:</p> <pre><code>from QIRT import QuantumState\n\nstate = QuantumState.from_label(\"r\", \"l\")\nstate.draw(target_basis=\"y\")\n</code></pre> <p>With the custom configuration above, this would output:</p> <p>$ \\frac{\\sqrt{2}}{2}|\\texttt{r}\\rangle_{0} +\\frac{\\sqrt{2}}{2}|\\texttt{l}\\rangle_{0} $</p>"},{"location":"how_to_guides/qubit_measurement/","title":"Qubit Measurement","text":"<p>This guide covers advanced usage of QIRT's <code>draw_measurement</code> function for quantum state measurement. We'll explore the function's parameters in depth and look at complex examples.</p>"},{"location":"how_to_guides/qubit_measurement/#detailed-parameters-of-draw_measurement","title":"Detailed Parameters of <code>draw_measurement</code>","text":"<p>The <code>draw_measurement</code> function in QIRT is highly customizable. Here's a breakdown of its parameters:</p> <ol> <li> <p><code>measure_bit</code>: List of integers specifying which qubits to measure. For example, [0, 2] would measure the first and third qubits.</p> </li> <li> <p><code>show_qubit_index</code>: Boolean. When True, qubit indices are shown in the visualization.</p> </li> <li> <p><code>output_length</code>: Integer controlling how many terms are shown per line in the output.</p> </li> <li> <p><code>source</code>: Boolean. When True, returns the LaTeX source code instead of rendering the output.</p> </li> <li> <p><code>target_basis</code>: List or string determining the measurement basis for measured qubits and the display basis for unmeasured qubits. Each element corresponds to a qubit in the state.</p> </li> </ol>"},{"location":"how_to_guides/qubit_measurement/#advanced-usage-of-target_basis","title":"Advanced Usage of <code>target_basis</code>","text":"<p>The <code>target_basis</code> parameter is particularly powerful. Let's explore its usage with examples:</p>"},{"location":"how_to_guides/qubit_measurement/#example-1-two-qubit-state","title":"Example 1: Two-qubit state","text":"<pre><code>state = QuantumState.from_label(\"+-\")\nstate.draw_measurement(measure_bit=[1], target_basis=\"zx\")\n</code></pre> <p>In this case:</p> <ul> <li>Qubit 1 (second qubit) is measured in the X basis.</li> <li>Qubit 0 (first qubit) is displayed in the Z basis.</li> </ul>"},{"location":"how_to_guides/qubit_measurement/#example-2-four-qubit-state","title":"Example 2: Four-qubit state","text":"<pre><code>state = QuantumState.from_label(\"+-+0\")\nstate.draw_measurement(measure_bit=[0, 2], target_basis=\"xzzx\")\n</code></pre> <p>Here:</p> <ul> <li>Qubit 0 is measured in the X basis.</li> <li>Qubit 2 is measured in the Z basis.</li> <li>Qubit 1 is displayed in the Z basis.</li> <li>Qubit 3 is displayed in the X basis.</li> </ul>"},{"location":"how_to_guides/qubit_measurement/#interpreting-complex-measurement-results","title":"Interpreting Complex Measurement Results","text":"<p>The output of <code>draw_measurement</code> provides a wealth of information:</p> <ol> <li>Measurement outcomes: The possible states after measurement.</li> <li>Probabilities: The likelihood of each outcome.</li> <li>Post-measurement states: The state of unmeasured qubits after measurement.</li> </ol> <p>For example, in a three-qubit system where we measure the first qubit:</p> <pre><code>state = QuantumState.from_label(\"000\", \"111\")\nstate.draw_measurement(measure_bit=[0])\n</code></pre> <p>The output might look like:</p> <p>\\(|\\texttt{0}\\rangle_{0} : |\\texttt{00}\\rangle_{12} (50\\%) \\\\ |\\texttt{1}\\rangle_{0} : |\\texttt{11}\\rangle_{12} (50\\%)\\)</p> <p>This tells us:</p> <ul> <li>There's a 50% chance of measuring |0\u27e9 in the first qubit, leaving the other qubits in state |00\u27e9.</li> <li>There's a 50% chance of measuring |1\u27e9 in the first qubit, leaving the other qubits in state |11\u27e9.</li> </ul>"},{"location":"how_to_guides/qubit_measurement/#advanced-measurement-scenarios","title":"Advanced Measurement Scenarios","text":""},{"location":"how_to_guides/qubit_measurement/#partial-measurement-of-entangled-states","title":"Partial Measurement of Entangled States","text":"<p>Consider the GHZ state:</p> <pre><code>ghz = QuantumState.from_label(\"000\", \"111\")\nghz.draw_measurement(measure_bit=[0, 1], target_basis=\"zx\")\n</code></pre> <p>This measures the first qubit in the Z basis and the second in the X basis, demonstrating how entanglement affects measurement outcomes.</p>"},{"location":"how_to_guides/qubit_measurement/#measuring-in-different-bases","title":"Measuring in Different Bases","text":"<pre><code>state = QuantumState.from_label(\"+\", \"-\")\nstate.draw_measurement(measure_bit=[0, 1], target_basis=\"xy\")\n</code></pre> <p>This measures a two-qubit state where the first qubit is in the X basis and the second in the Y basis, showcasing how measurement basis affects outcomes.</p>"},{"location":"how_to_guides/qubit_measurement/#conclusion","title":"Conclusion","text":"<p>Mastering <code>draw_measurement</code> allows for deep exploration of quantum measurement phenomena. Experiment with different states, measurement configurations, and bases to gain intuition about quantum behavior.</p> <p>Remember, quantum measurement is probabilistic and can dramatically alter the state of a system. Use these tools to visualize and understand these complex quantum effects.</p>"},{"location":"how_to_guides/visualize_states/","title":"Visualizing Quantum States","text":"<p>QIRT provides a powerful <code>draw</code> method to visualize quantum states in various formats. This method offers flexibility in how you want to represent and view your quantum states.</p>"},{"location":"how_to_guides/visualize_states/#basic-usage","title":"Basic Usage","text":"<p>To visualize a quantum state, simply call the <code>draw</code> method on a <code>QuantumState</code> object:</p> <pre><code>from QIRT import QuantumState\n\nstate = QuantumState.from_label((1/math.sqrt(2), \"00\"), (-1j/math.sqrt(2), \"11\"))\nstate.draw()\n</code></pre> <p>By default, this will produce a LaTeX representation of the state.</p>"},{"location":"how_to_guides/visualize_states/#customizing-the-output","title":"Customizing the Output","text":"<p>The <code>draw</code> method accepts several parameters to customize the visualization:</p>"},{"location":"how_to_guides/visualize_states/#1-output-format","title":"1. Output Format","text":"<p>You can specify the output format using the <code>output</code> parameter:</p> <pre><code># LaTeX format (default)\nstate.draw(output=\"latex\")\n\n# Matrix format\nstate.draw(output=\"matrix\")\n</code></pre>"},{"location":"how_to_guides/visualize_states/#2-target-basis","title":"2. Target Basis","text":"<p>You can visualize the state in different bases:</p> <pre><code># Visualize in X-basis\nstate.draw(target_basis=\"x\")\n\n# Visualize in Y-basis\nstate.draw(target_basis=\"y\")\n\n# Mix of bases\nstate.draw(target_basis=[\"x\", \"z\"])  # For a two-qubit state\n</code></pre>"},{"location":"how_to_guides/visualize_states/#3-qubit-indexing","title":"3. Qubit Indexing","text":"<p>Control whether to show qubit indices:</p> <pre><code># Hide qubit indices\nstate.draw(show_qubit_index=False)\n</code></pre>"},{"location":"how_to_guides/visualize_states/#4-output-length","title":"4. Output Length","text":"<p>Control how many terms appear per line:</p> <pre><code># 8 terms per line (2^3)\nstate.draw(output_length=3)\n</code></pre>"},{"location":"how_to_guides/visualize_states/#5-latex-source","title":"5. LaTeX Source","text":"<p>Get the LaTeX source code instead of rendering:</p> <pre><code>latex_source = state.draw(source=True)\nprint(latex_source)\n</code></pre>"},{"location":"how_to_guides/visualize_states/#examples","title":"Examples","text":"<p>Let's go through some examples to showcase these features:</p> <ol> <li> <p>Visualizing a Bell state</p> <pre><code>bell_state = QuantumState.from_label((1/math.sqrt(2), \"00\"), (1/math.sqrt(2), \"11\"))\nbell_state.draw()\n</code></pre> <p>&gt;&gt; Output: \\(\\frac{\\sqrt{2}}{2}|\\texttt{00}\\rangle_{01} + \\frac{\\sqrt{2}}{2}|\\texttt{11}\\rangle_{01}\\)</p> </li> <li> <p>Matrix representation</p> <pre><code># This will display the state vector as a column matrix.\nbell_state.draw(output=\"matrix\")\n</code></pre> <p>&gt;&gt; Output: </p> </li> <li> <p>Changing basis</p> <pre><code># This will show the Bell state represented in the X-basis.\nbell_state.draw(target_basis=\"x\")\n</code></pre> <p>&gt;&gt; Output: $ \\frac{\\sqrt{2}}{2}|\\texttt{++}\\rangle_{01} +\\frac{\\sqrt{2}}{2}|\\texttt{--}\\rangle_{01} $</p> </li> <li> <p>Changing output length</p> <pre><code>complex_state = QuantumState.from_label(\"000\", \"001\", \"010\", \"011\", \"100\", \"101\", \"110\", \"111\")\n# This will display the state with (2^output_length) terms per line.\ncomplex_state.draw(output_length=1)\n</code></pre> <p>&gt;&gt; Output: </p> </li> </ol>"},{"location":"reference/","title":"QIRT API Reference","text":"<p>Welcome to the API reference documentation for the Quantum Information Research Toolkit (QIRT). This section provides detailed information about the classes, methods, and functions available in QIRT.</p>"},{"location":"reference/#core-components","title":"Core Components","text":"<p>QIRT is built around two main components, both of which extend Qiskit's functionality:</p> <ol> <li> <p>QuantumState</p> <ul> <li>An extended version of Qiskit's Statevector class. It provides additional methods for quantum state manipulations, basis conversions, and visualizations.</li> </ul> </li> <li> <p>QuantumCircuit</p> <ul> <li>An extended version of Qiskit's QuantumCircuit class. It adds methods for basis conversion and visualization in matrix form.</li> </ul> </li> </ol>"},{"location":"reference/#getting-started","title":"Getting Started","text":"<p>If you're new to QIRT, we recommend starting with our Tutorials to get a hands-on introduction to the toolkit. For more specific use cases and advanced techniques, check out our How-to Guides.</p>"},{"location":"reference/#support","title":"Support","text":"<p>If you encounter any issues or have questions about using QIRT, please file an issue on our GitHub repository or reach out to our community support channels.</p>"},{"location":"reference/quantum_circuit/","title":"QuantumCircuit","text":"<p>An extended class of QuantumCircuit from Qiskit.</p> <p>This class extends the QuantumCircuit class from Qiskit to provide additional functionalities for converting basis and visualizing the quantum circuit in matrix form.</p> See Also <p>Qiskit QuantumCircuit documentation</p> Source code in <code>QIRT/quantum_circuit.py</code> <pre><code>class QuantumCircuit:\n    \"\"\"An extended class of QuantumCircuit from Qiskit.\n\n    This class extends the QuantumCircuit class from Qiskit to provide additional\n    functionalities for converting basis and visualizing the quantum circuit in\n    matrix form.\n\n    See Also:\n        [Qiskit QuantumCircuit documentation](https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html)\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize the QuantumCircuit class.\"\"\"\n        self._qiskit_qc = QiskitQC(*args, **kwargs)\n\n    def to_matrix(self) -&gt; NDArray[np.complex128]:\n        \"\"\"Return matrix form of the quantum circuit as a numpy array.\n\n        This method returns the matrix representation of the quantum circuit by\n        reversing the order of qubits to match textbook notation.\n\n        Returns:\n            NDArray[np.complex128]: The matrix representation of the quantum circuit.\n        \"\"\"\n        reverse_qc = self._qiskit_qc.reverse_bits()  # REVERSE the order of qubits to match textbook notation\n        return np.asarray(quantum_info.Operator(reverse_qc).data, dtype=np.complex128)\n\n    def draw(self, output: str | None = \"mpl\", source: bool = False, *args, **kwargs):\n        r\"\"\"Draw the quantum circuit, or show its matrix form if output is 'matrix'.\n\n        Args:\n            output (str | None, optional): The output format for drawing the circuit.\n                If 'text', generates ASCII art TextDrawing that can be printed in the console.\n                If 'mpl', generates images with color rendered purely in Python using matplotlib.\n                If 'latex', generates high-quality images compiled via latex.\n                If 'matrix', shows the matrix form of the circuit. Defaults to \"mpl\".\n            source (bool, optional): Whether to return the latex source code for the visualization. Defaults to False.\n            *args: Additional positional arguments to pass to the draw method.\n            **kwargs: Additional keyword arguments to pass to the draw method.\n\n        Returns:\n            The drawn circuit in the specified format.\n        \"\"\"\n        match output:\n            case \"matrix\":\n                return latex_drawer.matrix_to_latex(self.to_matrix(), source=source)\n            case \"latex\":\n                if source:\n                    return self._qiskit_qc.draw(output=\"latex_source\", *args, **kwargs)\n                return self._qiskit_qc.draw(output=\"latex\", *args, **kwargs)\n            case _:\n                return self._qiskit_qc.draw(output=output, *args, **kwargs)\n\n    def _xyz_convert_circ(self, target_basis: str, current_basis: str, qubit_index: int) -&gt; QuantumCircuit:\n        \"\"\"Add the corresponding gate that converts different basis.\n\n        This method adds the appropriate gates to the circuit to convert a qubit\n        from the current basis to the target basis.\n\n        Args:\n            target_basis (str): The target basis to convert to.\n            current_basis (str): The current basis of the qubit.\n            qubit_index (int): The index of the qubit to be converted.\n        \"\"\"\n        if current_basis == target_basis:\n            return self\n        current_basis += target_basis\n        match current_basis:\n            case \"zx\" | \"xz\":\n                self._qiskit_qc.h(qubit_index)\n            case \"zy\":\n                self._qiskit_qc.sdg(qubit_index)\n                self._qiskit_qc.h(qubit_index)\n            case \"yz\":\n                self._qiskit_qc.h(qubit_index)\n                self._qiskit_qc.s(qubit_index)\n            case \"xy\":\n                self._qiskit_qc.h(qubit_index)\n                self._qiskit_qc.sdg(qubit_index)\n                self._qiskit_qc.h(qubit_index)\n            case \"yx\":\n                self._qiskit_qc.h(qubit_index)\n                self._qiskit_qc.s(qubit_index)\n                self._qiskit_qc.h(qubit_index)\n        return self\n\n    def unitary(\n        self,\n        matrix: NDArray[np.complex128] | list[list[int]],\n        qubits: Sequence[QubitSpecifier],\n        label: str | None = None,\n    ) -&gt; QuantumCircuit:\n        \"\"\"Apply a unitary matrix to specified qubits.\n\n        This method applies a given unitary matrix to the specified qubits in the\n        quantum circuit. The matrix is converted to match the qubit order of the\n        quantum circuit by reversing the order of qubits.\n\n        Args:\n            matrix (NDArray[np.complex128] | list[list[int]]): The unitary matrix to apply.\n            qubits (Sequence[QubitSpecifier]): The qubits to which the unitary matrix will be applied.\n            label (str | None, optional): An optional label for the unitary gate. Defaults to None.\n\n        Returns:\n            QuantumCircuit: Quantum circuit with the applied unitary matrix.\n        \"\"\"\n        matrix = np.asarray(matrix, dtype=np.complex128)\n        matrix = inverse_tensor(matrix)  # REVERSE the order of qubits to match textbook notation\n        self._qiskit_qc.unitary(matrix, qubits, label=label)\n        return self\n\n    def __getattr__(self, name: str) -&gt; QuantumCircuit:\n        \"\"\"Return the original method if it returns an InstructionSet.\n\n        Args:\n            name (str): The name of the method to call\n\n        Raises:\n            AttributeError: If the method is not found in QuantumCircuit\n\n        Returns:\n            QuantumCircuit: The original method if it returns an InstructionSet.\n        \"\"\"\n        original_method = getattr(self._qiskit_qc, name)\n\n        def wrapper(*args, **kwargs):\n            result = original_method(*args, **kwargs)\n            if isinstance(result, InstructionSet):\n                return self\n            raise AttributeError(f\"Method {name} not found in QuantumCircuit\")\n\n        return wrapper\n</code></pre>"},{"location":"reference/quantum_circuit/#QIRT.QuantumCircuit.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Return the original method if it returns an InstructionSet.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the method to call</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the method is not found in QuantumCircuit</p> <p>Returns:</p> Name Type Description <code>QuantumCircuit</code> <code>QuantumCircuit</code> <p>The original method if it returns an InstructionSet.</p> Source code in <code>QIRT/quantum_circuit.py</code> <pre><code>def __getattr__(self, name: str) -&gt; QuantumCircuit:\n    \"\"\"Return the original method if it returns an InstructionSet.\n\n    Args:\n        name (str): The name of the method to call\n\n    Raises:\n        AttributeError: If the method is not found in QuantumCircuit\n\n    Returns:\n        QuantumCircuit: The original method if it returns an InstructionSet.\n    \"\"\"\n    original_method = getattr(self._qiskit_qc, name)\n\n    def wrapper(*args, **kwargs):\n        result = original_method(*args, **kwargs)\n        if isinstance(result, InstructionSet):\n            return self\n        raise AttributeError(f\"Method {name} not found in QuantumCircuit\")\n\n    return wrapper\n</code></pre>"},{"location":"reference/quantum_circuit/#QIRT.QuantumCircuit.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the QuantumCircuit class.</p> Source code in <code>QIRT/quantum_circuit.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize the QuantumCircuit class.\"\"\"\n    self._qiskit_qc = QiskitQC(*args, **kwargs)\n</code></pre>"},{"location":"reference/quantum_circuit/#QIRT.QuantumCircuit.draw","title":"<code>draw(output='mpl', source=False, *args, **kwargs)</code>","text":"<p>Draw the quantum circuit, or show its matrix form if output is 'matrix'.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str | None</code> <p>The output format for drawing the circuit. If 'text', generates ASCII art TextDrawing that can be printed in the console. If 'mpl', generates images with color rendered purely in Python using matplotlib. If 'latex', generates high-quality images compiled via latex. If 'matrix', shows the matrix form of the circuit. Defaults to \"mpl\".</p> <code>'mpl'</code> <code>source</code> <code>bool</code> <p>Whether to return the latex source code for the visualization. Defaults to False.</p> <code>False</code> <code>*args</code> <p>Additional positional arguments to pass to the draw method.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the draw method.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The drawn circuit in the specified format.</p> Source code in <code>QIRT/quantum_circuit.py</code> <pre><code>def draw(self, output: str | None = \"mpl\", source: bool = False, *args, **kwargs):\n    r\"\"\"Draw the quantum circuit, or show its matrix form if output is 'matrix'.\n\n    Args:\n        output (str | None, optional): The output format for drawing the circuit.\n            If 'text', generates ASCII art TextDrawing that can be printed in the console.\n            If 'mpl', generates images with color rendered purely in Python using matplotlib.\n            If 'latex', generates high-quality images compiled via latex.\n            If 'matrix', shows the matrix form of the circuit. Defaults to \"mpl\".\n        source (bool, optional): Whether to return the latex source code for the visualization. Defaults to False.\n        *args: Additional positional arguments to pass to the draw method.\n        **kwargs: Additional keyword arguments to pass to the draw method.\n\n    Returns:\n        The drawn circuit in the specified format.\n    \"\"\"\n    match output:\n        case \"matrix\":\n            return latex_drawer.matrix_to_latex(self.to_matrix(), source=source)\n        case \"latex\":\n            if source:\n                return self._qiskit_qc.draw(output=\"latex_source\", *args, **kwargs)\n            return self._qiskit_qc.draw(output=\"latex\", *args, **kwargs)\n        case _:\n            return self._qiskit_qc.draw(output=output, *args, **kwargs)\n</code></pre>"},{"location":"reference/quantum_circuit/#QIRT.QuantumCircuit.to_matrix","title":"<code>to_matrix()</code>","text":"<p>Return matrix form of the quantum circuit as a numpy array.</p> <p>This method returns the matrix representation of the quantum circuit by reversing the order of qubits to match textbook notation.</p> <p>Returns:</p> Type Description <code>NDArray[complex128]</code> <p>NDArray[np.complex128]: The matrix representation of the quantum circuit.</p> Source code in <code>QIRT/quantum_circuit.py</code> <pre><code>def to_matrix(self) -&gt; NDArray[np.complex128]:\n    \"\"\"Return matrix form of the quantum circuit as a numpy array.\n\n    This method returns the matrix representation of the quantum circuit by\n    reversing the order of qubits to match textbook notation.\n\n    Returns:\n        NDArray[np.complex128]: The matrix representation of the quantum circuit.\n    \"\"\"\n    reverse_qc = self._qiskit_qc.reverse_bits()  # REVERSE the order of qubits to match textbook notation\n    return np.asarray(quantum_info.Operator(reverse_qc).data, dtype=np.complex128)\n</code></pre>"},{"location":"reference/quantum_circuit/#QIRT.QuantumCircuit.unitary","title":"<code>unitary(matrix, qubits, label=None)</code>","text":"<p>Apply a unitary matrix to specified qubits.</p> <p>This method applies a given unitary matrix to the specified qubits in the quantum circuit. The matrix is converted to match the qubit order of the quantum circuit by reversing the order of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray[complex128] | list[list[int]]</code> <p>The unitary matrix to apply.</p> required <code>qubits</code> <code>Sequence[QubitSpecifier]</code> <p>The qubits to which the unitary matrix will be applied.</p> required <code>label</code> <code>str | None</code> <p>An optional label for the unitary gate. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QuantumCircuit</code> <code>QuantumCircuit</code> <p>Quantum circuit with the applied unitary matrix.</p> Source code in <code>QIRT/quantum_circuit.py</code> <pre><code>def unitary(\n    self,\n    matrix: NDArray[np.complex128] | list[list[int]],\n    qubits: Sequence[QubitSpecifier],\n    label: str | None = None,\n) -&gt; QuantumCircuit:\n    \"\"\"Apply a unitary matrix to specified qubits.\n\n    This method applies a given unitary matrix to the specified qubits in the\n    quantum circuit. The matrix is converted to match the qubit order of the\n    quantum circuit by reversing the order of qubits.\n\n    Args:\n        matrix (NDArray[np.complex128] | list[list[int]]): The unitary matrix to apply.\n        qubits (Sequence[QubitSpecifier]): The qubits to which the unitary matrix will be applied.\n        label (str | None, optional): An optional label for the unitary gate. Defaults to None.\n\n    Returns:\n        QuantumCircuit: Quantum circuit with the applied unitary matrix.\n    \"\"\"\n    matrix = np.asarray(matrix, dtype=np.complex128)\n    matrix = inverse_tensor(matrix)  # REVERSE the order of qubits to match textbook notation\n    self._qiskit_qc.unitary(matrix, qubits, label=label)\n    return self\n</code></pre>"},{"location":"reference/quantum_state/","title":"QuantumState","text":"<p>An extended class of Statevector from Qiskit.</p> <p>This class extends the Statevector class from Qiskit to provide additional functionalities specific to quantum state manipulations and measurements.</p> <p>Attributes:</p> Name Type Description <code>_num_of_qubit</code> <code>int</code> <p>The number of qubits in the quantum state.</p> See Also <p>Qiskit Statevector documentation</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>class QuantumState:\n    \"\"\"An extended class of Statevector from Qiskit.\n\n    This class extends the Statevector class from Qiskit to provide additional\n    functionalities specific to quantum state manipulations and measurements.\n\n    Attributes:\n        _num_of_qubit (int): The number of qubits in the quantum state.\n\n    See Also:\n        [Qiskit Statevector documentation](https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html)\n    \"\"\"\n\n    def __init__(\n        self,\n        data: np.ndarray | list | Statevector | Operator | QiskitQC | Instruction,\n        dims: int | tuple | list | None = None,\n    ):\n        \"\"\"Initialize a QuantumState object.\n\n        This constructor initializes the QuantumState object by calling the\n        constructor of the base Statevector class from Qiskit. It also calculates\n        and stores the number of qubits in the quantum state.\n\n        Args:\n            data (np.array or list or Statevector or Operator or QuantumCircuit or qiskit.circuit.Instruction):\n                Data from which the statevector can be constructed. This can be either a complex\n                vector, another statevector, a ``Operator`` with only one column or a\n                ``QuantumCircuit`` or ``Instruction``.  If the data is a circuit or instruction,\n                the statevector is constructed by assuming that all qubits are initialized to the\n                zero state.\n            dims (int or tuple or list): Optional. The subsystem dimension of the state (See additional information).\n        \"\"\"\n        if isinstance(data, (list | np.ndarray)):\n            # Normalize the state vector\n            data = np.asarray(data, dtype=complex)\n            data /= np.linalg.norm(data)\n        self.state_vector = Statevector(data, dims)\n        self._num_of_qubit = int(np.log2(len(self.state_vector.data)))\n\n    @property\n    def data(self) -&gt; NDArray[np.complex128]:\n        \"\"\"Get the data of the quantum state vector.\n\n        This property returns the data of the quantum state vector stored in the object.\n\n        Returns:\n            NDArray[np.complex128]: The data of the quantum state vector.\n        \"\"\"\n        return self.state_vector.data\n\n    @property\n    def num_of_qubit(self) -&gt; int:\n        \"\"\"Get the number of qubits in the quantum state.\n\n        This property returns the total number of qubits that are currently\n        represented in the quantum state vector.\n\n        Returns:\n            int: The number of qubits in the quantum state.\n        \"\"\"\n        return self._num_of_qubit\n\n    @classmethod\n    def from_label(cls, *args: str | tuple[complex, str]) -&gt; QuantumState:\n        \"\"\"Create a state vector from input coefficients and label strings.\n\n        Examples:\n            &gt;&gt;&gt; QuantumState.from_label(\"0\", \"1\")\n            (|0&gt; + |1&gt;)/\u221a2 QuantumState object.\n\n            &gt;&gt;&gt; QuantumState.from_label(\"00\", \"01\", \"10\", \"11\")\n            (|00&gt; + |01&gt; + |10&gt; + |11&gt;)/2 = |++&gt; QuantumState object.\n\n            &gt;&gt;&gt; QuantumState.from_label(\"+\", (-1, \"-\"))\n            (|+&gt; - |-&gt;)/\u221a2 QuantumState object.\n\n            &gt;&gt;&gt; QuantumState.from_label((2**0.5, \"0\"), \"+\", (-1, \"-\"))\n            (\u221a2|0&gt; + |+&gt; - |-&gt;)/2 = |+&gt; QuantumState object.\n\n            &gt;&gt;&gt; QuantumState.from_label(\"0\", (1j, \"1\"))\n            (|0&gt; + i|1&gt;)/\u221a2 = |i&gt; QuantumState object.\n\n        Args:\n            args (str | Tuple[complex, str]): Input label strings or tuples of coefficients and label strings.\n\n        Returns:\n            QuantumState: The state vector object.\n\n        Raises:\n            QiskitError: If labels contain invalid characters or if labels have different numbers of qubits.\n        \"\"\"\n        # Separate the input into coefficients and labels\n        coefficients: list[complex] = []\n        labels: list[str] = []\n        for i, arg in enumerate(args):\n            if isinstance(arg, tuple):  # Check if the input is a tuple of coefficient and label or just a label\n                coefficients.append(arg[0])\n                labels.append(arg[1])\n            else:\n                coefficients.append(1.0)\n                labels.append(arg)\n\n            if not Ket.check_valid(labels[i]):\n                raise QiskitError(\"Invalid label string.\")\n\n            if len(labels[0]) != len(labels[i]):\n                raise QiskitError(\"Each label's number of qubits must be the same.\")\n\n            labels[i] = Ket.to_qiskit_notation(labels[i])  # Convert the label to qiskit notation\n\n        # Create the state vector based on the input\n        state_vector: Statevector = Statevector.from_label(labels[0]) * coefficients[0]\n        for coefficient, label in zip(coefficients[1:], labels[1:]):\n            state_vector += Statevector.from_label(label) * coefficient\n\n        state_vector /= state_vector.trace() ** 0.5  # Normalize the state\n        return QuantumState(state_vector)\n\n    def entropy(self) -&gt; np.float64:\n        \"\"\"Calculate and return the Shannon  entropy of the quantum state.\n\n        The Shannon  entropy is a measure of the quantum state's uncertainty or mixedness.\n\n        Returns:\n            np.float64: The Shannon  entropy of the quantum state, calculated in base 2.\n        \"\"\"\n        entropy = stats.entropy(self.state_vector.probabilities(), base=2)\n        if type(entropy) is np.float64:\n            return entropy\n        raise QiskitError(\"Entropy calculation failed.\")\n\n    def apply(self, other: QuantumCircuit, qargs: list[int] | None = None) -&gt; QuantumState:\n        \"\"\"Apply a quantum circuit to the quantum state.\n\n        This method applies the given operator to the quantum state, evolving it\n        according to the operator's effect.\n\n        Args:\n            other (QuantumCircuit):\n                The operator used to evolve the quantum state.\n            qargs (list[int] | None, optional): A list of subsystem positions of\n                the QuantumState to apply the operator on. Defaults to None.\n\n        Returns:\n            QuantumState: The quantum state after evolution.\n\n        Raises:\n            QiskitError: If the operator dimension does not match the specified\n                quantum state subsystem dimensions.\n        \"\"\"\n        # REVERSE the order of qubits to fit qiskit notation\n        reversed_state_vector: Statevector = self.state_vector.reverse_qargs()\n        evolved_state_vector: Statevector = reversed_state_vector.evolve(other._qiskit_qc, qargs).reverse_qargs()\n        return QuantumState(evolved_state_vector)\n\n    def to_matrix(self) -&gt; NDArray[np.complex128]:\n        \"\"\"Convert the quantum state vector to a column matrix representation.\n\n        This method takes the quantum state vector stored in the object and converts\n        it into a column matrix form, which can be useful for various matrix-based\n        operations and calculations.\n\n        Returns:\n            NDArray[np.complex128]: The quantum state represented as a column matrix.\n        \"\"\"\n        flat_vector = self.state_vector.data\n        matrix = flat_vector[np.newaxis].T\n        return matrix\n\n    def draw(\n        self,\n        output: str = \"latex\",\n        target_basis: list[str] | str | None = None,\n        show_qubit_index: bool = True,\n        output_length: int = 2,\n        source: bool = False,\n    ):\n        \"\"\"Visualize the statevector.\n\n        This method provides different visualization options for the quantum state vector,\n        such as LaTeX, matrix/vector form, or other specified formats.\n\n        Args:\n            output (str, optional): Visualization method. Defaults to \"latex\". Options include:\n                - \"matrix\" or \"vector\": Outputs the state vector as a LaTeX formatted matrix.\n                - \"latex\": Outputs the state vector as a LaTeX formatted expression.\n            target_basis (List[str] | str | None, optional): The target basis for visualization. Defaults to None.\n            show_qubit_index (bool, optional): Whether to show qubit indices in the visualization. Defaults to True.\n            output_length (int, optional): The number of terms in each line, defined as 2^output_length.\n                                        Defaults to 2 (i.e., 4 terms per line).\n            source (bool, optional): Whether to return the latex source code for the visualization. Defaults to False.\n\n        Returns:\n            (matplotlib.Figure | str | TextMatrix | IPython.display.Latex | Latex): The visualization\n                output depending on the chosen method.\n        \"\"\"\n        match output:\n            case \"matrix\" | \"vector\":\n                return latex_drawer.matrix_to_latex(self.to_matrix(), source=source)\n            case \"latex\":\n                return latex_drawer.state_to_latex(\n                    state=self,\n                    current_basis=[\"z\"] * self.num_of_qubit,\n                    target_basis=target_basis,\n                    show_qubit_index=show_qubit_index,\n                    output_length=output_length,\n                    source=source,\n                )\n            case _:\n                raise QiskitError(\"Invalid output format.\")\n\n    def state_after_measurement(\n        self, measure_bit: list[int] | str, target_basis: list[str] | str = [], shot=100\n    ) -&gt; tuple[list[QuantumState], list[QuantumState]]:\n        \"\"\"Obtain the quantum state after a measurement.\n\n        This method returns the quantum states resulting from measuring specified qubits in a given basis.\n        It provides two lists of quantum states: the measured states in the Z basis and the system states\n        after measurement.\n\n        Args:\n            measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list of indices or a\n                string specifying the bits.\n            target_basis (List[str] | str, optional): The basis in which to perform the measurement.\n                Defaults to an empty list.\n            shot (int, optional): The number of measurement shots to perform. Defaults to 100.\n\n        Returns:\n            (Tuple[List[QuantumState], List[QuantumState]]):\n                - A list of quantum states representing the measurement results in the Z basis.\n                - A list of quantum states representing the system state after the measurement in the Z basis.\n        \"\"\"\n        z_basis_measure_state_list, z_basis_system_state_list, _, _, _, _ = self._measurement(\n            measure_bit=measure_bit, target_basis=target_basis, shot=shot\n        )\n        return (z_basis_measure_state_list, z_basis_system_state_list)\n\n    def draw_measurement(\n        self,\n        measure_bit: list[int] | str,\n        target_basis: list[str] | str = [],\n        show_qubit_index: bool = True,\n        output_length: int = 2,\n        source: bool = False,\n    ) -&gt; str | Latex:\n        \"\"\"Visualize the measurement results of the quantum state.\n\n        This method performs a measurement on specified qubits and visualizes the\n        resulting quantum states and their measurement outcomes in a specified format.\n\n        Args:\n            measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list\n                of indices or a string specifying the bits.\n            target_basis (List[str] | str, optional): The basis in which to perform the\n                measurement. Defaults to basis with minimum entropy.\n            show_qubit_index (bool, optional): Whether to show qubit indices in the\n                visualization. Defaults to True.\n            output_length (int, optional): The number of terms in each line, defined as\n                2^output_length. Defaults to 2 (i.e., 4 terms per line).\n            source (bool, optional): Whether to return the source code for the\n                visualization. Defaults to False.\n\n        Returns:\n            (str | Latex): The visualization of the measurement results,\n                either as an image or a string representing the source code.\n\n        Raises:\n            QiskitError: If the measurement basis or bit specifications are invalid.\n        \"\"\"\n        _, _, measure_state_list, system_state_list, measure_basis, system_basis = self._measurement(\n            measure_bit, target_basis\n        )\n        return latex_drawer.measure_result_to_latex(\n            measure_state_list=measure_state_list,\n            system_state_list=system_state_list,\n            measure_basis=measure_basis,\n            system_basis=system_basis,\n            measure_bit=measure_bit,\n            show_qubit_index=show_qubit_index,\n            output_length=output_length,\n            source=source,\n        )\n\n    def _basis_convert(\n        self,\n        target_basis: list[str] | str = [],\n        current_basis: list[str] | str = [],\n        algorithm: str = \"global\",\n    ) -&gt; tuple[QuantumState, list[str]]:\n        \"\"\"Convert the quantum state to a target basis.\n\n        This method converts the quantum state from its current basis to a specified\n        target basis using a quantum circuit. If the target basis is not fully specified,\n        it will auto-choose the basis with minimum entropy for unspecified qubits.\n\n        Args:\n            target_basis (List[str] | str, optional): The target basis for conversion. Defaults to an empty list.\n            current_basis (List[str] | str, optional): The current basis of the quantum state.\n                Defaults to an empty list.\n            algorithm (str, optional): The algorithm used for finding the minimum entropy basis. Defaults to \"global\".\n                Options are:\n                - \"global\": Global minimum entropy basis conversion.\n                - \"local\": Local minimum entropy basis conversion.\n\n        Returns:\n            (tuple[QuantumState, List[str]]): The converted quantum state and the list of the basis used for conversion.\n\n        Raises:\n            QiskitError: If the input basis is invalid or if an invalid algorithm is specified.\n        \"\"\"\n        # Default target_basis is auto choose basis with minimum entropy (basis = \"*\")\n        target_basis = list(target_basis) + [\"*\"] * (self.num_of_qubit - len(target_basis))\n        # Default current_basis is Z basis\n        current_basis = list(current_basis) + [\"z\"] * (self.num_of_qubit - len(current_basis))\n\n        # Check if input is valid\n        if re.match(R\"^[\\-\\*xyz]+$\", \"\".join(target_basis)) is None:\n            raise QiskitError(\"Invalid basis.\")\n\n        # Empty list to save auto-choose-basis index\n        auto_basis_index = []\n        # Convert basis using QuantumCircuit\n        convert_circ = QuantumCircuit(self.num_of_qubit)\n        for i in range(self.num_of_qubit):\n            if target_basis[i] == current_basis[i]:\n                continue\n            if target_basis[i] == \"*\" or target_basis[i] == \"-\":\n                auto_basis_index.append(i)\n                continue\n            convert_circ._xyz_convert_circ(target_basis=target_basis[i], current_basis=current_basis[i], qubit_index=i)\n            current_basis[i] = target_basis[i]\n\n        converted_state = self.apply(convert_circ)\n        if not auto_basis_index:\n            return (converted_state, current_basis)\n\n        # If user don't specify which basis to convert, convert basis to basis with minimum entropy\n        match algorithm:\n            case \"global\":\n                if len(auto_basis_index) &gt; 8:\n                    print(\n                        \"Notice: global minimum entropy basis convert with more then 8 qubits might take a long time.\"\n                    )\n                optimize_basis = converted_state._global_min_entropy_basis(auto_basis_index, current_basis)\n            case \"local\":\n                optimize_basis = converted_state._local_min_entropy_basis(auto_basis_index, current_basis)\n            case _:\n                raise QiskitError(\"Invalid min_entropy_basis_find_method.\")\n\n        return converted_state._basis_convert(target_basis=optimize_basis, current_basis=current_basis)\n\n    def _global_min_entropy_basis(self, auto_basis_index: list[int], current_basis: list[str]) -&gt; list[str]:\n        \"\"\"Find the basis with global minimum entropy.\n\n        This method searches for the basis configuration that minimizes the entropy\n        of the quantum state globally, by trying all possible combinations of the\n        specified bases at the auto-choose-basis indices.\n\n        Args:\n            auto_basis_index (List[int]): Indices of the qubits for which the basis\n                should be auto-chosen to minimize entropy.\n            current_basis (List[str]): The current basis of the quantum state.\n\n        Returns:\n            List[str]: The basis configuration with the global minimum entropy.\n        \"\"\"\n        num_of_auto_basis = len(auto_basis_index)\n        min_entropy = float(\"inf\")\n        min_basis = current_basis.copy()\n        try_basis = current_basis.copy()\n        for basis in itertools.product([\"z\", \"x\", \"y\"], repeat=num_of_auto_basis):\n            for i in range(num_of_auto_basis):\n                try_basis[auto_basis_index[i]] = basis[i]\n                try_state = self._basis_convert(target_basis=try_basis, current_basis=current_basis)[0]\n            if (entropy := try_state.entropy()) &lt; min_entropy:\n                min_entropy = entropy\n                min_basis = try_basis.copy()\n        return min_basis\n\n    def _local_min_entropy_basis(self, auto_basis_index: list[int], current_basis: list[str]) -&gt; list[str]:\n        \"\"\"Find the basis with local minimum entropy.\n\n        This method searches for the basis configuration that locally minimizes the entropy\n        of the quantum state by iteratively selecting the best basis for each qubit.\n\n        Args:\n            auto_basis_index (List[int]): Indices of the qubits for which the basis should be auto-chosen to\n                minimize entropy.\n            current_basis (List[str]): The current basis of the quantum state.\n\n        Returns:\n            List[str]: The basis configuration with the local minimum entropy.\n        \"\"\"\n        # Step 1: Change all auto-choose-basis to y, e.g. [-, -, -, -] -&gt; [z, z, z, z], calculate entropy\n        # Step 2,3: Same as Step 1, but with x-basis and y-basis\n        # Step 4: from Step 1 to 3, choose the basis with minimum entropy.\n        min_entropy = float(\"inf\")\n        min_basis = current_basis.copy()\n        for basis in [\"z\", \"x\", \"y\"]:\n            try_basis = min_basis.copy()\n            for i in auto_basis_index:\n                try_basis[i] = basis\n            try_state = self._basis_convert(target_basis=try_basis, current_basis=current_basis)[0]\n            if (entropy := try_state.entropy()) &lt; min_entropy:\n                min_entropy = entropy\n                min_basis = try_basis.copy()\n\n        # Step 1: Change the first auto-choose-basis to y, e.g. [-, -, -, -] -&gt; [y, -, -, -], calculate entropy,\n        # Step 2,3: Same as Step 1, but with x-basis and z-basis\n        # Step 4: from Step 1 to 3, choose the basis with minimum entropy.\n        # Step 5: Repeat Step 1 to 4 for the second auto-choose-basis, and so on. (greedy)\n        # e.g. [-, -, -, -] -&gt; [x, -, -, -] -&gt; [x, z, -, -] -&gt; [x, z, y, -] -&gt; [x, z, y, z]\n        for i in auto_basis_index:\n            try_basis = min_basis.copy()\n            for basis in [\"y\", \"x\", \"z\"]:\n                try_basis[i] = basis\n                try_state = self._basis_convert(target_basis=try_basis, current_basis=current_basis)[0]\n                if (entropy_tmp := try_state.entropy()) &lt; min_entropy:\n                    min_entropy = entropy_tmp\n                    min_basis[i] = basis\n        return min_basis\n\n    def _measurement(\n        self, measure_bit: list[int] | str, target_basis: list[str] | str = [], shot=-1\n    ) -&gt; tuple[list[QuantumState], list[QuantumState], list[QuantumState], list[QuantumState], list[str], list[str]]:\n        \"\"\"Perform a measurement on the quantum state.\n\n        This method measures the specified qubits in the given basis and returns the\n        resulting quantum states and measurement outcomes.\n\n        Args:\n            measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list\n                of indices or a string specifying the bits.\n            target_basis (List[str] | str, optional): The basis in which to perform the\n                measurement. Defaults to basis with minimum entropy.\n            shot (int, optional): The number of measurement shots to perform.\n                Defaults to depend on the number of qubits you want to measure. (2^(len(measure_bit) + 2))\n\n        Returns:\n            (tuple[list[QuantumState], list[QuantumState], list[QuantumState], list[QuantumState], list[str], list[str]]):\n                - z_basis_measure_state_list: Measurement states in the Z basis.\n                - z_basis_system_state_list: System states in the Z basis.\n                - measure_state_list: Measurement states in the original basis.\n                - system_state_list: System states in the original basis.\n                - measure_basis: The basis used for the measurement.\n                - system_basis: The system basis after conversion.\n        \"\"\"  # noqa: E501\n        if shot == -1:\n            shot = 2 ** (len(measure_bit) + 2)\n\n        if isinstance(measure_bit, str):\n            measure_bit = [int(i) for i in measure_bit]\n\n        converted_state, system_basis = self._basis_convert(\n            target_basis=target_basis, current_basis=[\"z\"] * self.num_of_qubit\n        )\n\n        # crate empty list for output\n        z_basis_measure_state_list: list[QuantumState] = [None] * 2 ** len(measure_bit)\n        z_basis_system_state_list: list[QuantumState] = [None] * 2 ** len(measure_bit)\n        measure_state_list: list[QuantumState] = [None] * 2 ** len(measure_bit)\n        system_state_list: list[QuantumState] = [None] * 2 ** len(measure_bit)\n        for _ in range(shot):\n            measure_ket, system_state = self._perform_single_shot_measurement(converted_state, measure_bit)\n            if measure_state_list[int(measure_ket, 2)] is None:\n                measure_basis = []\n                for i in measure_bit:\n                    measure_basis.append(system_basis[i])\n\n                basis_convert_measure_ket = \"\"\n                for b, k in zip(measure_basis, measure_ket):\n                    match b:\n                        case \"z\":\n                            basis_convert_measure_ket += Ket.z1 if int(k) else Ket.z0\n                        case \"x\":\n                            basis_convert_measure_ket += Ket.x1 if int(k) else Ket.x0\n                        case \"y\":\n                            basis_convert_measure_ket += Ket.y1 if int(k) else Ket.y0\n\n                measure_state_z_basis = self.from_label(basis_convert_measure_ket)\n\n                z_basis_measure_state_list[int(measure_ket, 2)] = measure_state_z_basis\n                z_basis_system_state_list[int(measure_ket, 2)] = system_state._basis_convert(\n                    target_basis=[\"z\"] * self.num_of_qubit, current_basis=system_basis\n                )[0]\n                measure_state_list[int(measure_ket, 2)] = measure_state_z_basis._basis_convert(\n                    target_basis=measure_basis\n                )[0]\n                system_state_list[int(measure_ket, 2)] = system_state\n\n        return (\n            z_basis_measure_state_list,\n            z_basis_system_state_list,\n            measure_state_list,\n            system_state_list,\n            measure_basis,\n            system_basis,\n        )\n\n    def _perform_single_shot_measurement(\n        self, converted_state: QuantumState, measure_bit: list[int]\n    ) -&gt; tuple[str, QuantumState]:\n        \"\"\"Perform a single shot measurement on the given quantum state.\n\n        This method measures the specified qubits in the given state and returns\n        the measurement result along with the post-measurement system state.\n\n        Args:\n            converted_state (QuantumState): The quantum state to measure.\n            measure_bit (List[int]): The indices of qubits to measure.\n\n        Returns:\n            Tuple[str, QuantumState]: A tuple containing:\n                - measure_ket (str): The measurement result as a ket string.\n                - system_state (QuantumState): The post-measurement system state.\n\n        Note:\n            This method reverses qubit ordering to match Qiskit's notation for measurement,\n            and then reverses the result to match standard textbook notation.\n        \"\"\"\n        measure_result: tuple[str, Statevector] = Statevector(converted_state.data).measure(\n            qargs=[self.num_of_qubit - 1 - i for i in measure_bit]  # REVERSE the order of qubits to fit qiskit notation\n        )\n        measure_ket: str = measure_result[0][::-1]  # REVERSE the order of qubits to fit textbook notation\n        system_state = QuantumState(measure_result[1])\n        return measure_ket, system_state\n</code></pre>"},{"location":"reference/quantum_state/#QIRT.QuantumState.data","title":"<code>data: NDArray[np.complex128]</code>  <code>property</code>","text":"<p>Get the data of the quantum state vector.</p> <p>This property returns the data of the quantum state vector stored in the object.</p> <p>Returns:</p> Type Description <code>NDArray[complex128]</code> <p>NDArray[np.complex128]: The data of the quantum state vector.</p>"},{"location":"reference/quantum_state/#QIRT.QuantumState.num_of_qubit","title":"<code>num_of_qubit: int</code>  <code>property</code>","text":"<p>Get the number of qubits in the quantum state.</p> <p>This property returns the total number of qubits that are currently represented in the quantum state vector.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of qubits in the quantum state.</p>"},{"location":"reference/quantum_state/#QIRT.QuantumState.__init__","title":"<code>__init__(data, dims=None)</code>","text":"<p>Initialize a QuantumState object.</p> <p>This constructor initializes the QuantumState object by calling the constructor of the base Statevector class from Qiskit. It also calculates and stores the number of qubits in the quantum state.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array or list or Statevector or Operator or QuantumCircuit or Instruction</code> <p>Data from which the statevector can be constructed. This can be either a complex vector, another statevector, a <code>Operator</code> with only one column or a <code>QuantumCircuit</code> or <code>Instruction</code>.  If the data is a circuit or instruction, the statevector is constructed by assuming that all qubits are initialized to the zero state.</p> required <code>dims</code> <code>int or tuple or list</code> <p>Optional. The subsystem dimension of the state (See additional information).</p> <code>None</code> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def __init__(\n    self,\n    data: np.ndarray | list | Statevector | Operator | QiskitQC | Instruction,\n    dims: int | tuple | list | None = None,\n):\n    \"\"\"Initialize a QuantumState object.\n\n    This constructor initializes the QuantumState object by calling the\n    constructor of the base Statevector class from Qiskit. It also calculates\n    and stores the number of qubits in the quantum state.\n\n    Args:\n        data (np.array or list or Statevector or Operator or QuantumCircuit or qiskit.circuit.Instruction):\n            Data from which the statevector can be constructed. This can be either a complex\n            vector, another statevector, a ``Operator`` with only one column or a\n            ``QuantumCircuit`` or ``Instruction``.  If the data is a circuit or instruction,\n            the statevector is constructed by assuming that all qubits are initialized to the\n            zero state.\n        dims (int or tuple or list): Optional. The subsystem dimension of the state (See additional information).\n    \"\"\"\n    if isinstance(data, (list | np.ndarray)):\n        # Normalize the state vector\n        data = np.asarray(data, dtype=complex)\n        data /= np.linalg.norm(data)\n    self.state_vector = Statevector(data, dims)\n    self._num_of_qubit = int(np.log2(len(self.state_vector.data)))\n</code></pre>"},{"location":"reference/quantum_state/#QIRT.QuantumState.apply","title":"<code>apply(other, qargs=None)</code>","text":"<p>Apply a quantum circuit to the quantum state.</p> <p>This method applies the given operator to the quantum state, evolving it according to the operator's effect.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>QuantumCircuit</code> <p>The operator used to evolve the quantum state.</p> required <code>qargs</code> <code>list[int] | None</code> <p>A list of subsystem positions of the QuantumState to apply the operator on. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>QuantumState</code> <code>QuantumState</code> <p>The quantum state after evolution.</p> <p>Raises:</p> Type Description <code>QiskitError</code> <p>If the operator dimension does not match the specified quantum state subsystem dimensions.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def apply(self, other: QuantumCircuit, qargs: list[int] | None = None) -&gt; QuantumState:\n    \"\"\"Apply a quantum circuit to the quantum state.\n\n    This method applies the given operator to the quantum state, evolving it\n    according to the operator's effect.\n\n    Args:\n        other (QuantumCircuit):\n            The operator used to evolve the quantum state.\n        qargs (list[int] | None, optional): A list of subsystem positions of\n            the QuantumState to apply the operator on. Defaults to None.\n\n    Returns:\n        QuantumState: The quantum state after evolution.\n\n    Raises:\n        QiskitError: If the operator dimension does not match the specified\n            quantum state subsystem dimensions.\n    \"\"\"\n    # REVERSE the order of qubits to fit qiskit notation\n    reversed_state_vector: Statevector = self.state_vector.reverse_qargs()\n    evolved_state_vector: Statevector = reversed_state_vector.evolve(other._qiskit_qc, qargs).reverse_qargs()\n    return QuantumState(evolved_state_vector)\n</code></pre>"},{"location":"reference/quantum_state/#QIRT.QuantumState.draw","title":"<code>draw(output='latex', target_basis=None, show_qubit_index=True, output_length=2, source=False)</code>","text":"<p>Visualize the statevector.</p> <p>This method provides different visualization options for the quantum state vector, such as LaTeX, matrix/vector form, or other specified formats.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>Visualization method. Defaults to \"latex\". Options include: - \"matrix\" or \"vector\": Outputs the state vector as a LaTeX formatted matrix. - \"latex\": Outputs the state vector as a LaTeX formatted expression.</p> <code>'latex'</code> <code>target_basis</code> <code>List[str] | str | None</code> <p>The target basis for visualization. Defaults to None.</p> <code>None</code> <code>show_qubit_index</code> <code>bool</code> <p>Whether to show qubit indices in the visualization. Defaults to True.</p> <code>True</code> <code>output_length</code> <code>int</code> <p>The number of terms in each line, defined as 2^output_length.                         Defaults to 2 (i.e., 4 terms per line).</p> <code>2</code> <code>source</code> <code>bool</code> <p>Whether to return the latex source code for the visualization. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Figure | str | TextMatrix | Latex | Latex</code> <p>The visualization output depending on the chosen method.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def draw(\n    self,\n    output: str = \"latex\",\n    target_basis: list[str] | str | None = None,\n    show_qubit_index: bool = True,\n    output_length: int = 2,\n    source: bool = False,\n):\n    \"\"\"Visualize the statevector.\n\n    This method provides different visualization options for the quantum state vector,\n    such as LaTeX, matrix/vector form, or other specified formats.\n\n    Args:\n        output (str, optional): Visualization method. Defaults to \"latex\". Options include:\n            - \"matrix\" or \"vector\": Outputs the state vector as a LaTeX formatted matrix.\n            - \"latex\": Outputs the state vector as a LaTeX formatted expression.\n        target_basis (List[str] | str | None, optional): The target basis for visualization. Defaults to None.\n        show_qubit_index (bool, optional): Whether to show qubit indices in the visualization. Defaults to True.\n        output_length (int, optional): The number of terms in each line, defined as 2^output_length.\n                                    Defaults to 2 (i.e., 4 terms per line).\n        source (bool, optional): Whether to return the latex source code for the visualization. Defaults to False.\n\n    Returns:\n        (matplotlib.Figure | str | TextMatrix | IPython.display.Latex | Latex): The visualization\n            output depending on the chosen method.\n    \"\"\"\n    match output:\n        case \"matrix\" | \"vector\":\n            return latex_drawer.matrix_to_latex(self.to_matrix(), source=source)\n        case \"latex\":\n            return latex_drawer.state_to_latex(\n                state=self,\n                current_basis=[\"z\"] * self.num_of_qubit,\n                target_basis=target_basis,\n                show_qubit_index=show_qubit_index,\n                output_length=output_length,\n                source=source,\n            )\n        case _:\n            raise QiskitError(\"Invalid output format.\")\n</code></pre>"},{"location":"reference/quantum_state/#QIRT.QuantumState.draw_measurement","title":"<code>draw_measurement(measure_bit, target_basis=[], show_qubit_index=True, output_length=2, source=False)</code>","text":"<p>Visualize the measurement results of the quantum state.</p> <p>This method performs a measurement on specified qubits and visualizes the resulting quantum states and their measurement outcomes in a specified format.</p> <p>Parameters:</p> Name Type Description Default <code>measure_bit</code> <code>List[int] | str</code> <p>The bits (qubits) to measure. Can be a list of indices or a string specifying the bits.</p> required <code>target_basis</code> <code>List[str] | str</code> <p>The basis in which to perform the measurement. Defaults to basis with minimum entropy.</p> <code>[]</code> <code>show_qubit_index</code> <code>bool</code> <p>Whether to show qubit indices in the visualization. Defaults to True.</p> <code>True</code> <code>output_length</code> <code>int</code> <p>The number of terms in each line, defined as 2^output_length. Defaults to 2 (i.e., 4 terms per line).</p> <code>2</code> <code>source</code> <code>bool</code> <p>Whether to return the source code for the visualization. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str | Latex</code> <p>The visualization of the measurement results, either as an image or a string representing the source code.</p> <p>Raises:</p> Type Description <code>QiskitError</code> <p>If the measurement basis or bit specifications are invalid.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def draw_measurement(\n    self,\n    measure_bit: list[int] | str,\n    target_basis: list[str] | str = [],\n    show_qubit_index: bool = True,\n    output_length: int = 2,\n    source: bool = False,\n) -&gt; str | Latex:\n    \"\"\"Visualize the measurement results of the quantum state.\n\n    This method performs a measurement on specified qubits and visualizes the\n    resulting quantum states and their measurement outcomes in a specified format.\n\n    Args:\n        measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list\n            of indices or a string specifying the bits.\n        target_basis (List[str] | str, optional): The basis in which to perform the\n            measurement. Defaults to basis with minimum entropy.\n        show_qubit_index (bool, optional): Whether to show qubit indices in the\n            visualization. Defaults to True.\n        output_length (int, optional): The number of terms in each line, defined as\n            2^output_length. Defaults to 2 (i.e., 4 terms per line).\n        source (bool, optional): Whether to return the source code for the\n            visualization. Defaults to False.\n\n    Returns:\n        (str | Latex): The visualization of the measurement results,\n            either as an image or a string representing the source code.\n\n    Raises:\n        QiskitError: If the measurement basis or bit specifications are invalid.\n    \"\"\"\n    _, _, measure_state_list, system_state_list, measure_basis, system_basis = self._measurement(\n        measure_bit, target_basis\n    )\n    return latex_drawer.measure_result_to_latex(\n        measure_state_list=measure_state_list,\n        system_state_list=system_state_list,\n        measure_basis=measure_basis,\n        system_basis=system_basis,\n        measure_bit=measure_bit,\n        show_qubit_index=show_qubit_index,\n        output_length=output_length,\n        source=source,\n    )\n</code></pre>"},{"location":"reference/quantum_state/#QIRT.QuantumState.entropy","title":"<code>entropy()</code>","text":"<p>Calculate and return the Shannon  entropy of the quantum state.</p> <p>The Shannon  entropy is a measure of the quantum state's uncertainty or mixedness.</p> <p>Returns:</p> Type Description <code>float64</code> <p>np.float64: The Shannon  entropy of the quantum state, calculated in base 2.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def entropy(self) -&gt; np.float64:\n    \"\"\"Calculate and return the Shannon  entropy of the quantum state.\n\n    The Shannon  entropy is a measure of the quantum state's uncertainty or mixedness.\n\n    Returns:\n        np.float64: The Shannon  entropy of the quantum state, calculated in base 2.\n    \"\"\"\n    entropy = stats.entropy(self.state_vector.probabilities(), base=2)\n    if type(entropy) is np.float64:\n        return entropy\n    raise QiskitError(\"Entropy calculation failed.\")\n</code></pre>"},{"location":"reference/quantum_state/#QIRT.QuantumState.from_label","title":"<code>from_label(*args)</code>  <code>classmethod</code>","text":"<p>Create a state vector from input coefficients and label strings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; QuantumState.from_label(\"0\", \"1\")\n(|0&gt; + |1&gt;)/\u221a2 QuantumState object.\n</code></pre> <pre><code>&gt;&gt;&gt; QuantumState.from_label(\"00\", \"01\", \"10\", \"11\")\n(|00&gt; + |01&gt; + |10&gt; + |11&gt;)/2 = |++&gt; QuantumState object.\n</code></pre> <pre><code>&gt;&gt;&gt; QuantumState.from_label(\"+\", (-1, \"-\"))\n(|+&gt; - |-&gt;)/\u221a2 QuantumState object.\n</code></pre> <pre><code>&gt;&gt;&gt; QuantumState.from_label((2**0.5, \"0\"), \"+\", (-1, \"-\"))\n(\u221a2|0&gt; + |+&gt; - |-&gt;)/2 = |+&gt; QuantumState object.\n</code></pre> <pre><code>&gt;&gt;&gt; QuantumState.from_label(\"0\", (1j, \"1\"))\n(|0&gt; + i|1&gt;)/\u221a2 = |i&gt; QuantumState object.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>str | Tuple[complex, str]</code> <p>Input label strings or tuples of coefficients and label strings.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>QuantumState</code> <code>QuantumState</code> <p>The state vector object.</p> <p>Raises:</p> Type Description <code>QiskitError</code> <p>If labels contain invalid characters or if labels have different numbers of qubits.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>@classmethod\ndef from_label(cls, *args: str | tuple[complex, str]) -&gt; QuantumState:\n    \"\"\"Create a state vector from input coefficients and label strings.\n\n    Examples:\n        &gt;&gt;&gt; QuantumState.from_label(\"0\", \"1\")\n        (|0&gt; + |1&gt;)/\u221a2 QuantumState object.\n\n        &gt;&gt;&gt; QuantumState.from_label(\"00\", \"01\", \"10\", \"11\")\n        (|00&gt; + |01&gt; + |10&gt; + |11&gt;)/2 = |++&gt; QuantumState object.\n\n        &gt;&gt;&gt; QuantumState.from_label(\"+\", (-1, \"-\"))\n        (|+&gt; - |-&gt;)/\u221a2 QuantumState object.\n\n        &gt;&gt;&gt; QuantumState.from_label((2**0.5, \"0\"), \"+\", (-1, \"-\"))\n        (\u221a2|0&gt; + |+&gt; - |-&gt;)/2 = |+&gt; QuantumState object.\n\n        &gt;&gt;&gt; QuantumState.from_label(\"0\", (1j, \"1\"))\n        (|0&gt; + i|1&gt;)/\u221a2 = |i&gt; QuantumState object.\n\n    Args:\n        args (str | Tuple[complex, str]): Input label strings or tuples of coefficients and label strings.\n\n    Returns:\n        QuantumState: The state vector object.\n\n    Raises:\n        QiskitError: If labels contain invalid characters or if labels have different numbers of qubits.\n    \"\"\"\n    # Separate the input into coefficients and labels\n    coefficients: list[complex] = []\n    labels: list[str] = []\n    for i, arg in enumerate(args):\n        if isinstance(arg, tuple):  # Check if the input is a tuple of coefficient and label or just a label\n            coefficients.append(arg[0])\n            labels.append(arg[1])\n        else:\n            coefficients.append(1.0)\n            labels.append(arg)\n\n        if not Ket.check_valid(labels[i]):\n            raise QiskitError(\"Invalid label string.\")\n\n        if len(labels[0]) != len(labels[i]):\n            raise QiskitError(\"Each label's number of qubits must be the same.\")\n\n        labels[i] = Ket.to_qiskit_notation(labels[i])  # Convert the label to qiskit notation\n\n    # Create the state vector based on the input\n    state_vector: Statevector = Statevector.from_label(labels[0]) * coefficients[0]\n    for coefficient, label in zip(coefficients[1:], labels[1:]):\n        state_vector += Statevector.from_label(label) * coefficient\n\n    state_vector /= state_vector.trace() ** 0.5  # Normalize the state\n    return QuantumState(state_vector)\n</code></pre>"},{"location":"reference/quantum_state/#QIRT.QuantumState.state_after_measurement","title":"<code>state_after_measurement(measure_bit, target_basis=[], shot=100)</code>","text":"<p>Obtain the quantum state after a measurement.</p> <p>This method returns the quantum states resulting from measuring specified qubits in a given basis. It provides two lists of quantum states: the measured states in the Z basis and the system states after measurement.</p> <p>Parameters:</p> Name Type Description Default <code>measure_bit</code> <code>List[int] | str</code> <p>The bits (qubits) to measure. Can be a list of indices or a string specifying the bits.</p> required <code>target_basis</code> <code>List[str] | str</code> <p>The basis in which to perform the measurement. Defaults to an empty list.</p> <code>[]</code> <code>shot</code> <code>int</code> <p>The number of measurement shots to perform. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>Tuple[List[QuantumState], List[QuantumState]]</code> <ul> <li>A list of quantum states representing the measurement results in the Z basis.</li> <li>A list of quantum states representing the system state after the measurement in the Z basis.</li> </ul> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def state_after_measurement(\n    self, measure_bit: list[int] | str, target_basis: list[str] | str = [], shot=100\n) -&gt; tuple[list[QuantumState], list[QuantumState]]:\n    \"\"\"Obtain the quantum state after a measurement.\n\n    This method returns the quantum states resulting from measuring specified qubits in a given basis.\n    It provides two lists of quantum states: the measured states in the Z basis and the system states\n    after measurement.\n\n    Args:\n        measure_bit (List[int] | str): The bits (qubits) to measure. Can be a list of indices or a\n            string specifying the bits.\n        target_basis (List[str] | str, optional): The basis in which to perform the measurement.\n            Defaults to an empty list.\n        shot (int, optional): The number of measurement shots to perform. Defaults to 100.\n\n    Returns:\n        (Tuple[List[QuantumState], List[QuantumState]]):\n            - A list of quantum states representing the measurement results in the Z basis.\n            - A list of quantum states representing the system state after the measurement in the Z basis.\n    \"\"\"\n    z_basis_measure_state_list, z_basis_system_state_list, _, _, _, _ = self._measurement(\n        measure_bit=measure_bit, target_basis=target_basis, shot=shot\n    )\n    return (z_basis_measure_state_list, z_basis_system_state_list)\n</code></pre>"},{"location":"reference/quantum_state/#QIRT.QuantumState.to_matrix","title":"<code>to_matrix()</code>","text":"<p>Convert the quantum state vector to a column matrix representation.</p> <p>This method takes the quantum state vector stored in the object and converts it into a column matrix form, which can be useful for various matrix-based operations and calculations.</p> <p>Returns:</p> Type Description <code>NDArray[complex128]</code> <p>NDArray[np.complex128]: The quantum state represented as a column matrix.</p> Source code in <code>QIRT/quantum_state.py</code> <pre><code>def to_matrix(self) -&gt; NDArray[np.complex128]:\n    \"\"\"Convert the quantum state vector to a column matrix representation.\n\n    This method takes the quantum state vector stored in the object and converts\n    it into a column matrix form, which can be useful for various matrix-based\n    operations and calculations.\n\n    Returns:\n        NDArray[np.complex128]: The quantum state represented as a column matrix.\n    \"\"\"\n    flat_vector = self.state_vector.data\n    matrix = flat_vector[np.newaxis].T\n    return matrix\n</code></pre>"},{"location":"tutorials/","title":"QIRT Tutorials","text":"<p>Welcome to the Quantum Information Research Toolkit (QIRT) tutorials. These guides will help you get started with QIRT and explore its features.</p> <ol> <li>Setup</li> <li>Create a Basic Quantum State</li> <li>Create a Basic Quantum Circuit</li> <li>Applye the Quantum Circuit to the Quantum State</li> <li>Measure the Quantum State</li> </ol> <p>Each tutorial provides step-by-step instructions and examples to help you understand and use QIRT effectively. We recommend going through these tutorials in order if you're new to QIRT.</p> <p>For more advanced usage, check out our How-To guides, and for detailed API documentation, please refer to our API Reference.</p> <p>Happy quantum computing with QIRT!</p>"},{"location":"tutorials/apply_circuit/","title":"Applying the Quantum Circuit to the Quantum State","text":"<p>After created a basic quantum circuit, the next step is to apply the circuit to the quantum state we created in step 1. This process is fundamental to quantum computing, as it allows you to manipulate and transform quantum states using the gates defined in your circuit. In this tutorial, we'll apply a quantum circuit to a quantum state to create a Bell state.</p>"},{"location":"tutorials/apply_circuit/#preparing-the-initial-state-and-circuit","title":"Preparing the Initial State and Circuit","text":"<p>Let's start by creating our initial quantum state and the quantum circuit we'll apply to it:</p> <pre><code>from QIRT import QuantumState, QuantumCircuit\n\n# Initialize the quantum state |00&gt;\ninit_state = QuantumState.from_label('00')\n\n# Create a two-qubit quantum circuit and add gates using method chaining\ncircuit = QuantumCircuit(2).h(0).cx(0, 1)\n</code></pre> <p>Here's what we've done:</p> <ol> <li>Created an initial state \\(|\\texttt{00}\\rangle\\) using the <code>from_label</code> method.</li> <li>Created a quantum circuit with two qubits.</li> <li>Added a Hadamard gate (H) to the first qubit (index 0).</li> <li>Added a CNOT gate with the first qubit as control and the second as target.</li> </ol>"},{"location":"tutorials/apply_circuit/#applying-the-quantum-circuit-to-the-quantum-state_1","title":"Applying the Quantum Circuit to the Quantum State","text":"<p>Now, let's apply the quantum circuit to the initial quantum state \\(|\\texttt{00}\\rangle\\), creating a Bell state:</p> <pre><code># Apply the quantum circuit to the quantum state\nBell_state = init_state.apply(circuit)\n\n# Visualize the Bell state\nBell_state.draw()\n</code></pre> <p>&gt;&gt; Output: $\\frac{\\sqrt{2}}{2}|\\texttt{00}\\rangle_{01} + \\frac{\\sqrt{2}}{2}|\\texttt{11}\\rangle_{01} $</p> <p>Now you have transformed the quantum state \\(|\\texttt{00}\\rangle\\) into a Bell state \\(\\frac{1}{\\sqrt{2}}(|\\texttt{00}\\rangle + |\\texttt{11}\\rangle)\\) using the quantum circuit.</p>"},{"location":"tutorials/apply_circuit/#understanding-the-result","title":"Understanding the Result","text":"<p>The resulting state is a Bell state, which is one of the four maximally entangled two-qubit states. This state is crucial in many quantum information protocols, such as quantum teleportation and superdense coding.</p> <ol> <li>The Hadamard gate (H) puts the first qubit into a superposition state.</li> <li>The CNOT gate entangles the two qubits, resulting in the Bell state.</li> </ol>"},{"location":"tutorials/apply_circuit/#next-steps","title":"Next Steps","text":"<p>Congratulations! You have now learned how to apply a quantum circuit to a quantum state.</p> <p>For more advanced usage, check out our How-To guides. These guides provide step-by-step instructions for specific tasks and use cases.</p> <p>For the detailed API documentation, please refer to our API Reference. This section includes comprehensive information on all QIRT functions, classes, and modules.</p> <p>Happy quantum computing with QIRT!</p>"},{"location":"tutorials/basic_create_circuit/","title":"Creating a Basic Quantum Circuit","text":"<p>After creating a basic quantum state \\(|\\texttt{00}\\rangle\\), the next step is to build a basic quantum circuit.</p>"},{"location":"tutorials/basic_create_circuit/#basic-circuit-creation","title":"Basic Circuit Creation","text":"<p>Let's start by creating a basic quantum circuit with two qubits:</p> <pre><code>from QIRT import QuantumCircuit\n\n# Create a two-qubit quantum circuit\ncircuit = QuantumCircuit(2)\n\n# Visualize the empty circuit\ncircuit.draw()\n</code></pre> <p>This creates an empty quantum circuit with two qubits.</p>"},{"location":"tutorials/basic_create_circuit/#adding-quantum-gates","title":"Adding Quantum Gates","text":"<p>Now, let's add some gates to our circuit. We'll create a circuit that prepares a Bell state, which is a maximally entangled state of two qubits.</p> <pre><code># Add a Hadamard gate on the circuit to qubit 0\ncircuit.h(0)\n\n# Add a CNOT gate on the circuit with control qubit 0 and target qubit 1\ncircuit.cx(0, 1)\n\n# Visualize the circuit\ncircuit.draw()\n</code></pre> <p>&gt;&gt; Output:</p> <p></p> <p>This circuit shows:</p> <ul> <li>A Hadamard gate (H) applied to qubit 0</li> <li>A CNOT gate with qubit 0 as the control and qubit 1 as the target</li> </ul>"},{"location":"tutorials/basic_create_circuit/#understanding-the-circuit","title":"Understanding the Circuit","text":"<ol> <li>The Hadamard gate (H) puts the first qubit into a superposition state.</li> <li>The CNOT gate entangles the two qubits.</li> </ol> <p>This particular circuit creates a Bell state, which is a fundamental resource in many quantum information protocols.</p>"},{"location":"tutorials/basic_create_circuit/#next-steps","title":"Next Steps","text":"<p>Now that you know how to create basic quantum circuits, you're ready to learn how to apply these circuits to quantum states. For more advanced circuit creation techniques, including method chaining and adding custom unitary operators, check out our How-To Guide on Creating Quantum Circuits.</p> <p>In the next tutorial, Applying the Quantum Circuit to the Quantum State, you'll see how quantum circuits transform quantum states, bringing together everything you've learned so far.</p>"},{"location":"tutorials/basic_create_state/","title":"Creating a Basic Quantum State","text":"<p>Let's start with the basics of QIRT: creating a simple quantum state. We'll focus on creating the state \\(|\\texttt{00}\\rangle\\) using bra-ket notation.</p>"},{"location":"tutorials/basic_create_state/#using-bra-ket-notation","title":"Using Bra-Ket Notation","text":"<p>QIRT provides a convenient method to create quantum states using bra-ket notation through the <code>from_label</code> method.</p> <pre><code>from QIRT import QuantumState\n\n# Create a quantum state |00&gt; from bra-ket notation\nstate = QuantumState.from_label(\"00\")\n\n# Visualize the state\nstate.draw()\n</code></pre> <p>&gt;&gt; Output: \\(|\\texttt{00}\\rangle_{01}\\)</p> <p>This creates the quantum state \\(|\\texttt{00}\\rangle\\), where both qubits are in the \\(|0\\rangle\\) state.</p> <p>You can also create other simple states:</p> <pre><code># Create |01&gt; state\nstate_01 = QuantumState.from_label(\"01\")\n\n# Create |1&gt; state (single qubit)\nstate_1 = QuantumState.from_label(\"1\")\n</code></pre>"},{"location":"tutorials/basic_create_state/#visualizing-quantum-states","title":"Visualizing Quantum States","text":"<p>As you've seen, we used the <code>draw()</code> method to visualize our quantum states. This method provides a basic representation of the state. For more advanced visualization techniques, including different output formats and customization options, please refer to our How-To Guide on Visualizing Quantum States.</p>"},{"location":"tutorials/basic_create_state/#next-steps","title":"Next Steps","text":"<p>Now that you've learned how to create and visualize basic quantum states, you're ready to move on to more advanced operations. For more advanced state creation techniques, including creating states from matrices and using coefficients, check out our How-To Guide on Creating Quantum States.</p> <p>The next tutorial will show you how to Create a Quantum Circuit, where you'll learn how to apply quantum gates to manipulate these states.</p>"},{"location":"tutorials/basic_measurement/","title":"Measuring Quantum States","text":"<p>After creating quantum states, the next step is often to measure them. In this tutorial, we'll learn the basics of measuring quantum states using QIRT.</p>"},{"location":"tutorials/basic_measurement/#introduction-to-quantum-measurement","title":"Introduction to Quantum Measurement","text":"<p>In quantum mechanics, measurement causes a quantum state to collapse into one of its basis states. The probability of each outcome depends on the state's amplitudes.</p>"},{"location":"tutorials/basic_measurement/#using-draw_measurement-in-qirt","title":"Using <code>draw_measurement</code> in QIRT","text":"<p>QIRT provides a <code>draw_measurement</code> method to visualize measurement results. Let's see a simple example:</p> <pre><code>from QIRT import QuantumState\n\n# Create a quantum state\nstate = QuantumState.from_label(\"01\",\"10\")  # Creates the state (|01&gt; + |10&gt;) / sqrt(2)\n\n# Measure the state and show the results\nstate.draw_measurement(measure_bit=[0])\n</code></pre> <p>This code creates a two-qubit state and measures the first qubit.</p>"},{"location":"tutorials/basic_measurement/#interpreting-the-results","title":"Interpreting the Results","text":"<p>The output shows:</p> <ul> <li>The possible measurement outcomes</li> <li>The state of the system after measurement</li> </ul> <p>This helps us understand how measurement affects quantum states.</p>"},{"location":"tutorials/basic_measurement/#next-steps","title":"Next Steps","text":"<p>Now that you've seen basic measurement, try creating different states and measuring them. For more advanced usage, check our How-To guide on quantum measurement.</p>"},{"location":"tutorials/setup/","title":"Setup","text":"<p>To get started with QIRT, you'll need to install it on your system. This tutorial will guide you through the installation process.</p>"},{"location":"tutorials/setup/#prerequisites","title":"Prerequisites","text":"<p>QIRT requires Python 3.10 or later. Make sure you have a compatible version of Python installed on your system.</p>"},{"location":"tutorials/setup/#installing-qirt","title":"Installing QIRT","text":"<p>You can install QIRT using pip, Python's package installer. Open your terminal or command prompt and run the following command:</p> <pre><code>pip install QIRT\n</code></pre> <p>This command will download and install QIRT along with its dependencies.</p>"},{"location":"tutorials/setup/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To verify that QIRT has been installed correctly, you can import it in a Python environment:</p> <pre><code>from importlib.metadata import version\n\nversion(\"QIRT\")\n</code></pre> <p>If this runs without any errors and prints the version number, you've successfully installed QIRT!</p>"},{"location":"tutorials/setup/#setting-up-jupyter-notebook","title":"Setting up jupyter notebook","text":"<p>We recommend using Jupyter Notebook for the best experience with QIRT. Here's how to set it up:</p> <ol> <li> <p>Install Jupyter:</p> <pre><code>pip install jupyter\n</code></pre> </li> <li> <p>Launch Jupyter Notebook:</p> <pre><code>jupyter notebook\n</code></pre> </li> <li> <p>Create a new notebook and you're ready to start!</p> </li> </ol>"},{"location":"tutorials/setup/#next-steps","title":"Next Steps","text":"<p>Now that you have QIRT installed and Jupyter Notebook set up, you're ready to dive into quantum computing with QIRT! Here are the next tutorials to guide you through the basics:</p> <ol> <li>Create a Basic Quantum State</li> <li>Create a Basic Quantum Circuit</li> <li>Apply the Quantum Circuit to the Quantum State</li> <li>Measure the Quantum State</li> </ol>"}]}